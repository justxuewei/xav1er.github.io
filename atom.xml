<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.nxw.name</id>
    <title>Xavier&apos;s Blog</title>
    <updated>2020-09-01T08:47:21.343Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.nxw.name"/>
    <link rel="self" href="https://www.nxw.name/atom.xml"/>
    <subtitle>About code, about life, about everything.</subtitle>
    <logo>https://www.nxw.name/images/avatar.png</logo>
    <icon>https://www.nxw.name/favicon.ico</icon>
    <rights>All rights reserved 2020, Xavier&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[OpenCore UEFI Disappers from Boot Options after Reset NVRAM]]></title>
        <id>https://www.nxw.name/post/opencore-uefi-disappers-from-boot-options-after-cleaned-nvram/</id>
        <link href="https://www.nxw.name/post/opencore-uefi-disappers-from-boot-options-after-cleaned-nvram/">
        </link>
        <updated>2020-09-01T08:06:49.000Z</updated>
        <summary type="html"><![CDATA[<p>I surprisedly notice that OpenCore UEFI option has gone away after &quot;reset NVRAM&quot; option was selected. To solve that, you should prepare an empty USB formatted in FAT32.</p>
]]></summary>
        <content type="html"><![CDATA[<p>I surprisedly notice that OpenCore UEFI option has gone away after &quot;reset NVRAM&quot; option was selected. To solve that, you should prepare an empty USB formatted in FAT32.</p>
<!-- more -->
<h1 id="access-to-uefi-shell">Access to UEFI Shell</h1>
<ol>
<li>Create a dictionary on the USB Device: <code>/EFI/BOOT</code>.</li>
<li>Copy the file <code>shell.efi</code> which could be downloaded from <a href="https://github.com/xavier-niu/pub/blob/master/hackintosh/shell.efi">this</a> to the directiory created above.</li>
<li>Rename <code>shell.efi</code> to <code>BOOTx64.efi</code>.</li>
<li>Reboot your device and choose the UEFI Shell from boot options of BIOS.</li>
</ol>
<h1 id="add-a-new-boot-record">Add A New Boot Record</h1>
<ol>
<li>Run <code>bcfg boot dump</code>, <strong>Boot ID</strong> is an arbitrary number as long as it is not conflicted with existed one.</li>
<li>Run <code>map</code>, then find the disk at which Hackintosh was installed. Please be aware that <strong>DISK ID</strong> of the disk has a prefix with <code>FS</code>.</li>
<li>Run <code>bcfg boot add &lt;BOOT ID&gt; &lt;DISK ID&gt;:\EFI\BOOT\BOOTx64.efi OpenCore</code>. Please replace the BOOT ID &amp; DISK ID with yours.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OMD开始进入快速开发期]]></title>
        <id>https://www.nxw.name/post/omd-kai-shi-jin-ru-kuai-su-kai-fa-qi/</id>
        <link href="https://www.nxw.name/post/omd-kai-shi-jin-ru-kuai-su-kai-fa-qi/">
        </link>
        <updated>2020-08-09T10:01:06.000Z</updated>
        <summary type="html"><![CDATA[<p>吐槽一下苹果文档，就是一个字：烂。对于macOS开发者极不友好，在0202年的今天依然保留着很多远古时期的产物，比如NSCell，对于NSCell和NSControl的作用关系的文档存在于Archived Documents（最近一次更新在2008年），而且只是泛泛而谈，很多细节展现的并不完美，即便是在新文档中很多方法甚至连说明都没有，anyway这方面的开发只能慢慢来了。希望SwiftUI完善一段时间后，可以有不错的文档和对macOS完善的支持。</p>
]]></summary>
        <content type="html"><![CDATA[<p>吐槽一下苹果文档，就是一个字：烂。对于macOS开发者极不友好，在0202年的今天依然保留着很多远古时期的产物，比如NSCell，对于NSCell和NSControl的作用关系的文档存在于Archived Documents（最近一次更新在2008年），而且只是泛泛而谈，很多细节展现的并不完美，即便是在新文档中很多方法甚至连说明都没有，anyway这方面的开发只能慢慢来了。希望SwiftUI完善一段时间后，可以有不错的文档和对macOS完善的支持。</p>
<!-- more -->
<p>在OH! My Dictionary的开发中，我希望逐渐尝试一些的新的技术，比如RxSwift，但是将会严重的拖慢我的速度，但是好在现在对Cocoa Programming逐渐熟悉起来了，下一步应该就是着重对MVVC模式以及RxSwift的研究，祝我好运！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[How DelegateProxy works in RxSwift?]]></title>
        <id>https://www.nxw.name/post/how-delegateproxy-works-in-rxswift/</id>
        <link href="https://www.nxw.name/post/how-delegateproxy-works-in-rxswift/">
        </link>
        <updated>2020-03-12T13:30:54.000Z</updated>
        <summary type="html"><![CDATA[<p>DelegateProxy is a core feature in Rxswift to wrap the return value from original delegate to observable sequence. So it's important to discover how it works in RxSwift. Under the hood, message forwarding, a feature in Objective-C, plays a role in forwarding message from proxy to real delegate. You should have some basic knowledges about Objective-C Runtime before you go deeper. You can learn that in this post (Chinese version): <a href="https://www.nxw.name/post/objective-c-runtime-xiang-jie/">Objective-C Runtime详解</a>.</p>
]]></summary>
        <content type="html"><![CDATA[<p>DelegateProxy is a core feature in Rxswift to wrap the return value from original delegate to observable sequence. So it's important to discover how it works in RxSwift. Under the hood, message forwarding, a feature in Objective-C, plays a role in forwarding message from proxy to real delegate. You should have some basic knowledges about Objective-C Runtime before you go deeper. You can learn that in this post (Chinese version): <a href="https://www.nxw.name/post/objective-c-runtime-xiang-jie/">Objective-C Runtime详解</a>.</p>
<!-- more -->
<h1 id="use-cases">Use Cases</h1>
<p>There are two ways to apply DelegateProxy to your app in different scenarios:</p>
<ul>
<li>Delegate method has a return value.</li>
<li>Delegate method hasn't a return value, in other words, the type of method is void.</li>
</ul>
<p>Here are some reasons about why we need differential measure to the two cases above, which I quoted from <em>RxSwift Reactive Programming with Swift</em>:</p>
<ul>
<li>Delegate methods with a return type are not meant for observation, but for customization of the behavior.</li>
<li>Deﬁning an automatic default value which would work in any case is a non-trivial task.</li>
</ul>
<h2 id="has-not-a-return-value">HAS NOT a Return Value</h2>
<p>We use <code>sentMessage(Selector)</code> or <code>methodInvoked(Selector)</code> to establish a relationship between a selector which represents the method in Delegate you want to invoke and a observable sequence. The difference between those methods is whether elements are sent before message forwarding or not. More details about that will be introduced in the later.</p>
<pre><code class="language-swift">var didUpdateLocations: Observable&lt;[CLLocation]&gt; { 
	return delegate
		.methodInvoked(#selector(CLLocationManagerDelegate.locationManager(_:didUpdateLocations:)))
		.map { parameters in
			return parameters[1] as! [CLLocation]
		} 
}
</code></pre>
<h2 id="has-a-return-value">HAS a Return Value</h2>
<p>As we discussed before, a method that has a return value is not easy to be wrapped to observable, therefore we need to forward the invocation to real delegate. Suppose you want to <code>MapViewDelegate</code> work with RxSwift, you have a file named <code>MKMapView+Rx.swift</code> for making <code>MapViewDelegate</code> reactive and a file named <code>ViewController.swift</code> which conforms to <code>MKMapViewDelegate</code> as usual.</p>
<pre><code class="language-swift">// MKMapView+Rx.swift

// install a forwarding delegate
func setDelegate(_ delegate: MKMapViewDelegate) -&gt; Disposable {
    return RxMKMapViewDelegateProxy.installForwardDelegate(
    	delegate, 
    	retainDelegate: false, 
    	onProxyForObject: self.base
    )
 }

// manipulate how map view displays when new data have been arrived
var overlays: Binder&lt;[MKOverlay]&gt; {
    return Binder(self.base) { (mapView: Base, overLays: [MKOverlay]) in
      mapView.removeOverlays(mapView.overlays)
      mapView.addOverlays(overLays)
    }
  }
</code></pre>
<p>Then, you can call this function to set up with the real delegate instance.</p>
<pre><code class="language-swift">// ViewController.swift

// register forwarding delegate
mapView.rx.setDelegate(self).disposed(by: bag)

// regular protocol implementation
extension ViewController: MKMapViewDelegate {
  public func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer {
    guard let overlay = overlay as? ApiController.Weather.Overlay else {
      return MKOverlayRenderer()
    }
    let overlayView = ApiController.Weather.OverlayView(overlay: overlay, overlayIcon: overlay.icon)
    return overlayView
  }
}
</code></pre>
<p>You may confuse after viewing this code. Don't worry! You can understand them better after you learned how forwarding delegate works.</p>
<h1 id="registering-a-proxy">Registering a Proxy</h1>
<p>According to the source code, we can find all methods related to register is in <code>DelegateProxyType.swift</code>. Let me show you how we register a proxy in an extension of ParentObject first.</p>
<p>We can find those methods in source code.</p>
<p>Protocol: DelegateProxyType</p>
<pre><code class="language-swift">// abstract static method
static func registerKnownImplementations()

// `DelegateProxy.identifer` is, in fact, an identifier of Delegate.
public static var identifier: UnsafeRawPointer {
    let delegateIdentifier = ObjectIdentifier(Delegate.self)
    let integerIdentifier = Int(bitPattern: delegateIdentifier)
    return UnsafeRawPointer(bitPattern: integerIdentifier)!
}

// static method
public static func register&lt;Parent&gt;(make: @escaping (Parent) -&gt; Self) {
    self.factory.extend(make: make)
}

// self.factory
private static var factory: DelegateProxyFactory {
    DelegateProxyFactory.sharedFactory(for: self)
}
</code></pre>
<p>Class: DelegateProxyFactory</p>
<pre><code class="language-swift">private class DelegateProxyFactory {
  private static var _sharedFactories: [UnsafeRawPointer: DelegateProxyFactory] = [:]

    fileprivate static func sharedFactory&lt;DelegateProxy: DelegateProxyType&gt;(for proxyType: DelegateProxy.Type) -&gt; DelegateProxyFactory {
        MainScheduler.ensureRunningOnMainThread()
        let identifier = DelegateProxy.identifier
        if let factory = _sharedFactories[identifier] {
            return factory
        }
        let factory = DelegateProxyFactory(for: proxyType)
        _sharedFactories[identifier] = factory
        DelegateProxy.registerKnownImplementations()
        return factory
    }

    private var _factories: [ObjectIdentifier: (AnyObject) -&gt; AnyObject]
    private var _identifier: UnsafeRawPointer
  
    // ...

    fileprivate func extend&lt;DelegateProxy: DelegateProxyType, ParentObject&gt;(make: @escaping (ParentObject) -&gt; DelegateProxy) {
        MainScheduler.ensureRunningOnMainThread()
        precondition(_identifier == DelegateProxy.identifier, &quot;Delegate proxy has inconsistent identifier&quot;)
        guard _factories[ObjectIdentifier(ParentObject.self)] == nil else {
            rxFatalError(&quot;The factory of \(ParentObject.self) is duplicated. DelegateProxy is not allowed of duplicated base object type.&quot;)
        }
        _factories[ObjectIdentifier(ParentObject.self)] = { make(castOrFatalError($0)) }
    }
  
  // ...
}
</code></pre>
<p>Notes</p>
<ul>
<li>
<p>Mapping relations between <code>Delegate</code> and an instance of <code>DelegateProxyFactory</code> are saved in <code>_sharedFactories</code>, and mapping relations between <code>ParentObject</code> and <code>Proxy</code> for each <code>Delegate</code> are saved in <code>_factories</code>, an instance variable in <code>DelegateProxyFactory</code>.</p>
</li>
<li>
<p>Method saving the relations mentioned above is <code>sharedFactory(for: DelegateProxy.Type) -&gt; DelegateProxyFactory</code> and <code>extend(make: @escaping (ParentObject) -&gt; DelegateProxy)</code>. It's easy to understand what happens if you neglect the code for log.</p>
</li>
</ul>
<p>You override <code>registerKnownImplementations()</code> in the root of proxy and register all proxies corresponding to views that are inherited from root, since <code>createProxy(_:)</code> in the factory creates proxy is based on what type of object you pass is and root proxy shares the same variable, e.g. <code>xxx.rx.delegate</code>, with their children.</p>
<p>For example, we know that the hierarchical relation in UITableView is: UITableView &gt; UIScrollView &gt; UIView.</p>
<pre><code class="language-swift">// RxScrollViewDelegateProxy.swift
public static func registerKnownImplementations() {
    self.register { RxScrollViewDelegateProxy(scrollView: $0) }
    self.register { RxTableViewDelegateProxy(tableView: $0) }
    self.register { RxCollectionViewDelegateProxy(collectionView: $0) }
    self.register { RxTextViewDelegateProxy(textView: $0) }
}
</code></pre>
<p>In this case, UIScrollView is root, of course, its corresponding proxy, RxScrollViewDelegateProxy, is root as well. Therefore, in <code>registerKnownImplementations()</code> it registers all proxies of children, including <code>RxTableViewDelegateProxy</code>. And now you glance through the source code of <code>UIScrollView+Rx.swift</code> and <code>UITableView+Rx.swift</code>.</p>
<pre><code class="language-swift">// UIScrollView+Rx.swift
public var delegate: DelegateProxy&lt;UIScrollView, UIScrollViewDelegate&gt; {
    return RxScrollViewDelegateProxy.proxy(for: base)
}
</code></pre>
<p>Although there is no definition about delegate in <code>UITableView+Rx.swift</code>, in some methods they use <code>self.delegate</code> to call methods in Delegate.</p>
<pre><code class="language-swift">// UITableView+Rx.swift
public var itemSelected: ControlEvent&lt;IndexPath&gt; {
    let source = delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:didSelectRowAt:)))
        .map { a in
            try castOrThrow(IndexPath.self, a[1])
        }
    return ControlEvent(events: source)
}
</code></pre>
<p>The reason is that <code>RxScrollViewDelegateProxy.proxy(for:)</code> calls <code>createProxy(_:)</code> finally. <code>createProxy(_:)</code>, however, creates proxy depends on what type of object you passed in. For example,  you call <code>delegate</code> in <code>UITableView+Rx.swift</code>, <code>base</code> passing to <code>RxScrollViewDelegateProxy.proxy</code> is an instance of <code>UITableView</code>, then the return type of proxy from <code>createProxy(_:)</code> is <code>RxTableViewDelegateProxy</code>.</p>
<p>Here is a flowchart to show you the process about registration.</p>
<pre><code class="language-flow">st=&gt;start: Start
e=&gt;end: End
initFormat=&gt;operation: init self.factory
performShareFactory=&gt;operation: sharedFactory(for:)
hasFactoryInstance=&gt;condition: has factory 
instance?
returnFactory=&gt;operation: return factory
regKnownImp=&gt;operation: registerKnownImplementation()
register=&gt;operation: register()
extend=&gt;operation: extend()
saveRelation=&gt;operation: save mapper to factory
(parentObj &gt; proxy) 


st-&gt;initFormat(right)-&gt;performShareFactory
performShareFactory-&gt;hasFactoryInstance
hasFactoryInstance(yes)-&gt;returnFactory
hasFactoryInstance(no)-&gt;regKnownImp(right)-&gt;register(right)-&gt;extend-&gt;saveRelation
saveRelation(left)-&gt;returnFactory-&gt;e
</code></pre>
<h1 id="creating-a-proxy">Creating a Proxy</h1>
<p>As usual, we extend a class to create a proxy and use it as Delegate. To create a proxy, we perform <code>proxy(object: ParentObject)</code> to get an instance of <code>DelegateProxy</code> from the factory of DelegateProxy.</p>
<pre><code class="language-swift">public extension Reactive where Base: CLLocationManager {
    var delegate: DelegateProxy&lt;CLLocationManager, CLLocationManagerDelegate&gt; {
        return RxCLLocationManagerDelegateProxy.proxy(for: base)
    }
}
</code></pre>
<p>Although creating a proxy could be done in less than three lines of code, RxSwift really does a lot for implementing those functions. The following codes scattered all over the place show you all related stuffs to this process.</p>
<p>Protocol: DelegateProxyType.swift</p>
<pre><code class="language-swift">extension DelegateProxyType {
    // ...
    public static func proxy(for object: ParentObject) -&gt; Self {
        MainScheduler.ensureRunningOnMainThread()

        let maybeProxy = assignedProxy(for: object)

        let proxy: AnyObject
        if let existingProxy = maybeProxy {
            proxy = existingProxy
        } else {
            proxy = castOrFatalError(createProxy(for: object))
            assignProxy(proxy, toObject: object)
            assert(assignedProxy(for: object) === proxy)
        }
        let currentDelegate = _currentDelegate(for: object)
        let delegateProxy: Self = castOrFatalError(proxy)

        if currentDelegate !== delegateProxy {
          	// save the forwarded delegate in `__forwardToDelegate` defined 
          	// in `_RXDelegateProxy.m`
            delegateProxy._setForwardToDelegate(currentDelegate, retainDelegate: false)
            assert(delegateProxy._forwardToDelegate() === currentDelegate)
            // set current proxy as delegate of object 
            _setCurrentDelegate(proxy, to: object)
            assert(_currentDelegate(for: object) === proxy)
            assert(delegateProxy._forwardToDelegate() === currentDelegate)
        }

        return delegateProxy
    }
  	// ...
}

extension DelegateProxyType {
    static func _currentDelegate(for object: ParentObject) -&gt; AnyObject? {
        currentDelegate(for: object).map { $0 as AnyObject }
    }
    
    static func _setCurrentDelegate(_ delegate: AnyObject?, to object: ParentObject) {
        setCurrentDelegate(castOptionalOrFatalError(delegate), to: object)
    }
    
    func _forwardToDelegate() -&gt; AnyObject? {
        self.forwardToDelegate().map { $0 as AnyObject }
    }
    
    func _setForwardToDelegate(_ forwardToDelegate: AnyObject?, retainDelegate: Bool) {
      	// setForwardToDelegate is defined in DelegateProxy.swift
        self.setForwardToDelegate(castOptionalOrFatalError(forwardToDelegate), retainDelegate: retainDelegate)
    }
}

extension DelegateProxyType where ParentObject: HasDelegate, Self.Delegate == ParentObject.Delegate {
    public static func currentDelegate(for object: ParentObject) -&gt; Delegate? {
        object.delegate
    }
    public static func setCurrentDelegate(_ delegate: Delegate?, to object: ParentObject) {
        object.delegate = delegate
    }
}

extension DelegateProxyType {
 	 // ...
    public static func createProxy(for object: AnyObject) -&gt; Self {
        castOrFatalError(factory.createProxy(for: object))
    }
  	// ...
}

private class DelegateProxyFactory {
  	// ...
    fileprivate func createProxy(for object: AnyObject) -&gt; AnyObject {
        MainScheduler.ensureRunningOnMainThread()
        var maybeMirror: Mirror? = Mirror(reflecting: object)
        while let mirror = maybeMirror {
            if let factory = _factories[ObjectIdentifier(mirror.subjectType)] {
                return factory(object)
            }
            maybeMirror = mirror.superclassMirror
        }
        rxFatalError(&quot;DelegateProxy has no factory of \(object). Implement DelegateProxy subclass for \(object) first.&quot;)
    }
}
</code></pre>
<p>Class: DelegateProxy.swift</p>
<pre><code class="language-swift">open class DelegateProxy&lt;P: AnyObject, D&gt;: _RXDelegateProxy {
  	// ...
  	private var _sentMessageForSelector = [Selector: MessageDispatcher]()
    private var _methodInvokedForSelector = [Selector: MessageDispatcher]()
  
    open func setForwardToDelegate(_ delegate: Delegate?, retainDelegate: Bool) {
        #if DEBUG // 4.0 all configurations
            MainScheduler.ensureRunningOnMainThread()
        #endif
      	// _setForwardToDelegate is defined in _RXDelegateProxy.m
        _setForwardToDelegate(delegate, retainDelegate: retainDelegate)

        let sentSelectors: [Selector] = _sentMessageForSelector.values.filter { $0.hasObservers }.map { $0.selector }
        let invokedSelectors: [Selector] = _methodInvokedForSelector.values.filter { $0.hasObservers }.map { $0.selector }
        let allUsedSelectors = sentSelectors + invokedSelectors

        for selector in Set(allUsedSelectors) {
            checkSelectorIsObservable(selector)
        }
        reset()
    }
  
  	fileprivate func reset() {
        guard let parentObject = _parentObject else { return }

      	// definiation in init(): self._currentDelegateFor = delegateProxy._currentDelegate
        let maybeCurrentDelegate = _currentDelegateFor(parentObject)

        if maybeCurrentDelegate === self {
          	// definiation in init(): self._setCurrentDelegateTo = delegateProxy._setCurrentDelegate
            _setCurrentDelegateTo(nil, parentObject)
            _setCurrentDelegateTo(castOrFatalError(self), parentObject)
        }
    }
  	// ...
}
</code></pre>
<p>Class: _RXDelegateProxy.m</p>
<pre><code class="language-objc">id __weak __forwardToDelegate;

-(void)_setForwardToDelegate:(id __nullable)forwardToDelegate retainDelegate:(BOOL)retainDelegate {
    __forwardToDelegate = forwardToDelegate;
    if (retainDelegate) {
        self.strongForwardDelegate = forwardToDelegate;
    }
    else {
        self.strongForwardDelegate = nil;
    }
}
</code></pre>
<p>Notes:</p>
<ul>
<li><code>checkSelectorIsObservable(selector:)</code> does nothing, but just outputs some warning message.</li>
</ul>
<p>The flowchart of proxy creation is</p>
<pre><code class="language-flow">st=&gt;start: call RXxxxDelegateProxy.proxy(for:)
e=&gt;end: Return Proxy
mayProxy=&gt;condition: mayProxy?
proxy=&gt;inputoutput: proxy
callCreateProxy=&gt;operation: call createProxy(for:)
get proxy from factory
CDChanged=&gt;condition: CurrentDelegate 
changed?
call_setForwardToDelegate=&gt;operation: call _setForwardToDelegate(_:retainDelegate:)
to save forwarded delegate
call_setCurrentDelegate=&gt;operation: call _setCurrentDelegate(_:to:)
to set proxy as delegate of object

st(right)-&gt;mayProxy
mayProxy(yes, bottom)-&gt;proxy
mayProxy(no, right)-&gt;callCreateProxy-&gt;proxy
proxy-&gt;CDChanged
CDChanged(no, bottom)-&gt;e
CDChanged(yes, right)-&gt;call_setForwardToDelegate-&gt;call_setCurrentDelegate(left)-&gt;e
</code></pre>
<h1 id="wrapping-to-observable">Wrapping to Observable</h1>
<p>Class <code>MessageDispatcher</code> has a <code>dispatcher</code>, an instance of <code>PublishSubject</code>, and <code>result</code>, an observable of <code>dispatcher</code>, which you can subscribe it to get events of delegate.</p>
<pre><code class="language-swift">private final class MessageDispatcher {
    private let dispatcher: PublishSubject&lt;[Any]&gt;
    private let result: Observable&lt;[Any]&gt;
  	// ...
    init&lt;P, D&gt;(selector: Selector, delegateProxy _delegateProxy: DelegateProxy&lt;P, D&gt;) {
        // ...
        result = dispatcher
            .do(onSubscribed: { weakDelegateProxy?.checkSelectorIsObservable(selector); weakDelegateProxy?.reset() }, onDispose: { weakDelegateProxy?.reset() })
            .share()
            .subscribeOn(mainScheduler)
    }
    
    // ...
}
</code></pre>
<p>DelegateProxy has <code>_sentMessageForSelector</code> and <code>_methodInvokedForSelector</code> to map a selector corresponding to a method of delegate to an instance of <code>MessageDispatcher</code>.</p>
<pre><code class="language-swift">private var _sentMessageForSelector = [Selector: MessageDispatcher]()
private var _methodInvokedForSelector = [Selector: MessageDispatcher]()
</code></pre>
<p>You now can emit an event by <code>_sentMessage(_:withArguments:)</code> and <code>_methodInvoked(_:withArguments:)</code>.</p>
<pre><code class="language-swift">open override func _sentMessage(_ selector: Selector, withArguments arguments: [Any]) {
    _sentMessageForSelector[selector]?.on(.next(arguments))
}

open override func _methodInvoked(_ selector: Selector, withArguments arguments: [Any]) {
    _methodInvokedForSelector[selector]?.on(.next(arguments))
}
</code></pre>
<p><code>methodInvoked(_:)</code> and <code>sentMessage(_:)</code> saves the mapper into the dictionary and returns <code>result</code>, an member variable in <code>MessageDispather</code> we discussed above.</p>
<pre><code class="language-swift">open func sentMessage(_ selector: Selector) -&gt; Observable&lt;[Any]&gt; {
    MainScheduler.ensureRunningOnMainThread()

    let subject = _sentMessageForSelector[selector]

    if let subject = subject {
        return subject.asObservable()
    } else {
        let subject = MessageDispatcher(selector: selector, delegateProxy: self)
        _sentMessageForSelector[selector] = subject
        return subject.asObservable()
    }
}

open func methodInvoked(_ selector: Selector) -&gt; Observable&lt;[Any]&gt; {
    MainScheduler.ensureRunningOnMainThread()

    let subject = _methodInvokedForSelector[selector]

    if let subject = subject {
        return subject.asObservable()
    } else {
        let subject = MessageDispatcher(selector: selector, delegateProxy: self)
        _methodInvokedForSelector[selector] = subject
        return subject.asObservable()
    }
}
</code></pre>
<p><code>DelegateProxy</code> inherits from <code>_RXDelegateProxy</code>, which contains codes about message forwarding to ensure the message could be forwarded to original delegate, written by Objective-C. When someone calls a function of original delegate on proxy <code>forwardInvocation:</code> will be performed, because proxy can't respond to the selector.</p>
<pre><code class="language-objc">-(void)forwardInvocation:(NSInvocation *)anInvocation {
    BOOL isVoid = RX_is_method_signature_void(anInvocation.methodSignature);
    NSArray *arguments = nil;

    if (isVoid) {
        arguments = RX_extract_arguments(anInvocation);
        [self _sentMessage:anInvocation.selector withArguments:arguments];
    }

    if (self._forwardToDelegate &amp;&amp; [self._forwardToDelegate respondsToSelector:anInvocation.selector]) {
        [anInvocation invokeWithTarget:self._forwardToDelegate];
    }

    if (isVoid) {
        [self _methodInvoked:anInvocation.selector withArguments:arguments];
    }
}
</code></pre>
<p>Notes:</p>
<ul>
<li><code>_sentMessage:withArguments:</code> and <code>_methodInvoked:withArguments:</code> will be invoked if the return type of method is void.</li>
<li><code>_sentMessage:withArguments:</code> is performed before the message forwards to delegate, and <code>_methodInvoked:withArguments:</code> after that.</li>
</ul>
<p>Why void methods are differentiated from others? Comments from RXSwift give answer:</p>
<blockquote>
<p>Only methods that have <code>void</code> return value can be observed using this method because those methods are used as a notification mechanism. It doesn't matter if they are optional or not. Observing is performed by installing a hidden associated <code>PublishSubject</code> that is used to dispatch messages to observers.</p>
<p>Delegate methods that have non <code>void</code> return value can't be observed directly using this method because:</p>
<ul>
<li>those methods are not intended to be used as a notification mechanism, but as a behavior customization mechanism</li>
<li>there is no sensible automatic way to determine a default return value</li>
</ul>
</blockquote>
<p>You can overwrite the method of delegate to let proxy response to, here is an example:</p>
<pre><code class="language-swift">public func scrollViewDidScroll(_ scrollView: UIScrollView) {
    if let subject = _contentOffsetBehaviorSubject {
        subject.on(.next(scrollView.contentOffset))
    }
    if let subject = _contentOffsetPublishSubject {
        subject.on(.next(()))
    }
    // DO NOT forget to forward to delegate
    self._forwardToDelegate?.scrollViewDidScroll?(scrollView)
}
</code></pre>
<h1 id="conclusion">Conclusion</h1>
<p>Discovering how RxSwift works is an nice exprience for me. I learned how to wrap a regular method to observable stream, and many underlying knowledges about iOS and programming language, such as Objective-C Runtime. Source code, in fact, is not too difficult to read if you determined to do it. You will understand what mechanisms are behind Apis and work with them more elegantly once mastered each part of source code.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Objective-C Runtime详解]]></title>
        <id>https://www.nxw.name/post/objective-c-runtime-xiang-jie/</id>
        <link href="https://www.nxw.name/post/objective-c-runtime-xiang-jie/">
        </link>
        <updated>2020-03-06T06:57:54.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>最近在学习RxSwift，对于DelegateProxy如何进行消息转发问题比较感兴趣，所以仔细阅读了源码，发现其在底层利用了Objective-C Runtime的特性实现消息转发，因此在网上找到了这一系列的文章。<br>
这篇文章大部分内容转自<a href="http://southpeak.github.io/categories/objectivec/">南峰子的技术博客</a>。由于年代久远的关系，其部分图片已经404，遂在这篇文章中进行补齐，同时对于文中描述的一些不是很清楚的内容加入了我的理解。<br>
实际上该系列文章下分六篇独立文章，在我的版本中将单独的文章予以合并以图后续查阅方便。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>最近在学习RxSwift，对于DelegateProxy如何进行消息转发问题比较感兴趣，所以仔细阅读了源码，发现其在底层利用了Objective-C Runtime的特性实现消息转发，因此在网上找到了这一系列的文章。<br>
这篇文章大部分内容转自<a href="http://southpeak.github.io/categories/objectivec/">南峰子的技术博客</a>。由于年代久远的关系，其部分图片已经404，遂在这篇文章中进行补齐，同时对于文中描述的一些不是很清楚的内容加入了我的理解。<br>
实际上该系列文章下分六篇独立文章，在我的版本中将单独的文章予以合并以图后续查阅方便。</p>
</blockquote>
<!-- more -->
<p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时能够更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。</p>
<p>这种特性意味着Objective-C不仅需要一个编译器，还需要一个<mark>运行时系统</mark>来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即Objc Runtime。Objc Runtime其实是一个Runtime库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>
<p>Runtime库主要做下面几件事：</p>
<p>封装：在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</p>
<p>找出方法的最终执行代码：当程序执行[object doSomething]时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者是否能响应该消息而做出不同的反应。这将在后面详细介绍。</p>
<p>Objective-C runtime目前有两个版本：Modern runtime和Legacy runtime。Modern Runtime 覆盖了64位的Mac OS X Apps，还有 iOS Apps，Legacy Runtime 是早期用来给32位 Mac OS X Apps 用的，也就是可以不用管就是了。</p>
<p>在这一系列文章中，我们将介绍runtime的基本工作原理，以及如何利用它让我们的程序变得更加灵活。在本文中，我们先来介绍一下类与对象，这是面向对象的基础，我们看看在Runtime中，类是如何实现的。</p>
<h1 id="类与对象基础数据结构">类与对象基础数据结构</h1>
<h2 id="objc_class">objc_class</h2>
<p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：</p>
<pre><code class="language-c">typedef struct objc_class *Class;
</code></pre>
<p>查看objc/runtime.h中objc_class结构体的定义如下：</p>
<pre><code class="language-c">struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class super_class                       OBJC2_UNAVAILABLE;  // 父类
    const char *name                        OBJC2_UNAVAILABLE;  // 类名
    long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0
    long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识
    long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小
    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表
    struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表
    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存
    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表
#endif

} OBJC2_UNAVAILABLE;
</code></pre>
<p>在这个定义中，下面几个字段是我们感兴趣的：</p>
<ul>
<li>isa：需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的Class里面也有一个isa指针，它指向metaClass(元类)，我们会在后面介绍它。</li>
<li>super_class：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则super_class为NULL。</li>
<li>cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。</li>
<li>version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</li>
</ul>
<p>针对cache，我们用下面例子来说明其执行过程：</p>
<pre><code class="language-objc">NSArray *array = [[NSArray alloc] init];
</code></pre>
<p>其流程是：</p>
<ul>
<li>[NSArray alloc]先被执行。因为NSArray没有+alloc方法，于是去父类NSObject去查找。</li>
<li>检测NSObject是否响应+alloc方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把<mark>isa指针指向NSArray类</mark>。同时，+alloc也被加进cache列表里面。</li>
<li>接着，执行-init方法，如果NSArray响应该方法，则直接将其加入cache；如果不响应，则去父类查找。</li>
</ul>
<p>在后期的操作中，如果再以[[NSArray alloc] init]这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。</p>
<h2 id="objc_object与id">objc_object与id</h2>
<p>objc_object是表示一个类的实例的结构体，它的定义如下(objc/objc.h)：</p>
<pre><code class="language-c">struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};

typedef struct objc_object *id;
</code></pre>
<p>可以看到，这个结构体只有一个成员，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。</p>
<p>当创建一个特定类的实例对象时，分配的内存包含一个objc_object数据结构，然后是类的实例变量的数据。NSObject类的alloc和allocWithZone:方法使用函数class_createInstance来创建objc_object数据结构。</p>
<p>另外还有我们常见的id，它是一个objc_object结构类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中void *指针类型的作用。</p>
<h2 id="objc_cache">objc_cache</h2>
<p>上面提到了objc_class结构体中的cache字段，它用于缓存调用过的方法。这个字段是一个指向objc_cache结构体的指针，其定义如下：</p>
<pre><code class="language-c">struct objc_cache {
    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;
    unsigned int occupied                                    OBJC2_UNAVAILABLE;
    Method buckets[1]                                        OBJC2_UNAVAILABLE;
};
</code></pre>
<p>该结构体的字段描述如下：</p>
<ul>
<li>mask：一个整数，指定分配的缓存bucket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法。</li>
<li>occupied：一个整数，指定实际占用的缓存bucket的总数。</li>
<li>buckets：指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。</li>
</ul>
<h2 id="元类meta-class">元类(meta class)</h2>
<p>在上面我们提到，<mark>所有的类自身也是一个对象</mark>，我们可以向这个对象发送消息(即调用类方法)。如：</p>
<pre><code class="language-objc">NSArray *array = [NSArray array];
</code></pre>
<p>这个例子中，+array消息发送给了NSArray类，而这个NSArray也是一个对象。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么这些就有一个问题了，这个isa指针指向什么呢？为了调用+array方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念：</p>
<p>meta-class是一个类对象的类。</p>
<p><mark>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</mark></p>
<p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p>
<p>再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。这样就形成了一个完美的闭环。</p>
<p>通过上面的描述，再加上对objc_class结构体中super_class指针的分析，我们就可以描绘出类及相应meta-class类的一个继承体系了，如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="http://res.niuxuewei.com/2020-03-05-072215.png" alt="Screen-Shot-2016-03-04-at-12-14-44-AM-1" loading="lazy"></figure>
<p>对于NSObject继承体系来说，其实例方法对体系中的所有实例、类和meta-class都是有效的；而类方法对于体系内的所有类和meta-class都是有效的。</p>
<p>讲了这么多，我们还是来写个例子吧：</p>
<pre><code class="language-objc">void TestMetaClass(id self, SEL _cmd) {

    NSLog(@&quot;This objcet is %p&quot;, self);
    NSLog(@&quot;Class is %@, super class is %@&quot;, [self class], [self superclass]);

    Class currentClass = [self class];
    for (int i = 0; i &lt; 4; i++) {
        NSLog(@&quot;Following the isa pointer %d times gives %p&quot;, i, currentClass);
        currentClass = objc_getClass((__bridge void *)currentClass);
    }

    NSLog(@&quot;NSObject's class is %p&quot;, [NSObject class]);
    NSLog(@&quot;NSObject's meta class is %p&quot;, objc_getClass((__bridge void *)[NSObject class]));
}

#pragma mark -

@implementation Test

- (void)ex_registerClassPair {

    Class newClass = objc_allocateClassPair([NSError class], &quot;TestClass&quot;, 0);
    class_addMethod(newClass, @selector(testMetaClass), (IMP)TestMetaClass, &quot;v@:&quot;);
    objc_registerClassPair(newClass);

    id instance = [[newClass alloc] initWithDomain:@&quot;some domain&quot; code:0 userInfo:nil];
    [instance performSelector:@selector(testMetaClass)];
}

@end
</code></pre>
<p>这个例子是在运行时创建了一个<code>NSError</code>的子类<code>TestClass</code>，然后为这个子类添加一个方法<code>testMetaClass</code>，这个方法的实现是<code>TestMetaClass</code>函数。</p>
<p>运行后，打印结果是</p>
<pre><code>2014-10-20 22:57:07.352 mountain[1303:41490] This objcet is 0x7a6e22b0
2014-10-20 22:57:07.353 mountain[1303:41490] Class is TestStringClass, super class is NSError
2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 0 times gives 0x7a6e21b0
2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 1 times gives 0x0
2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 2 times gives 0x0
2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 3 times gives 0x0
2014-10-20 22:57:07.353 mountain[1303:41490] NSObject's class is 0xe10000
2014-10-20 22:57:07.354 mountain[1303:41490] NSObject's meta class is 0x0
</code></pre>
<p>我们在for循环中，我们通过<code>objc_getClass</code>来获取对象的<code>isa</code>，并将其打印出来，依此一直回溯到NSObject的<code>meta-class</code>。分析打印结果，可以看到最后指针指向的地址是0x0，即NSObject的<code>meta-class</code>的类地址。</p>
<p><em>这里需要注意的是：我们在一个类对象调用class方法是无法获取meta-class，它只是返回类而已。</em></p>
<h1 id="类与对象操作函数">类与对象操作函数</h1>
<p>runtime提供了大量的函数来操作类与对象。类的操作方法大部分是以<code>class_</code>为前缀的，而对象的操作方法大部分是以<code>objc_</code>或<code>object_</code>为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。</p>
<h2 id="类相关操作函数">类相关操作函数</h2>
<p>我们可以回过头去看看<code>objc_class</code>的定义，runtime提供的操作类的方法主要就是针对这个结构体中的各个字段的。下面我们分别介绍这一些的函数。并在最后以实例来演示这些函数的具体用法。</p>
<h3 id="类名name">类名(name)</h3>
<p>类名操作的函数主要有：</p>
<pre><code class="language-c">// 获取类的类名
const char * class_getName ( Class cls );
</code></pre>
<p>说明：</p>
<ul>
<li>对于<code>class_getName</code>函数，如果传入的<code>cls</code>为<code>Nil</code>，则返回一个字符串。</li>
</ul>
<h3 id="父类super_class和元类meta-class">父类(super_class)和元类(meta-class)</h3>
<p>父类和元类操作的函数主要有：</p>
<pre><code class="language-c">// 获取类的父类
Class class_getSuperclass ( Class cls );
// 判断给定的Class是否是一个元类
BOOL class_isMetaClass ( Class cls );
</code></pre>
<p>说明：</p>
<ul>
<li><code>class_getSuperclass</code>函数，当<code>cls</code>为Nil或者<code>cls</code>为根类时，返回Nil。不过通常我们可以使用NSObject类的<code>superclass</code>方法来达到同样的目的。</li>
<li><code>class_isMetaClass</code>函数，如果是<code>cls</code>是元类，则返回YES；如果否或者传入的<code>cls</code>为Nil，则返回NO。</li>
</ul>
<h3 id="实例变量大小instance_size">实例变量大小(instance_size)</h3>
<p>实例变量大小操作的函数有：</p>
<pre><code class="language-c">// 获取实例大小
size_t class_getInstanceSize ( Class cls );
</code></pre>
<h3 id="成员变量ivars及属性">成员变量(ivars)及属性</h3>
<p>在<code>objc_class</code>中，所有的成员变量、属性的信息是放在链表<code>ivars</code>中的。<code>ivars</code>是一个数组，数组中每个元素是指向<code>Ivar</code>(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：</p>
<blockquote>
<p>Marked by Xavier：</p>
<ul>
<li>
<p>有关成员变量、属性的相关内容请参见：https://www.jianshu.com/p/55f781f8c915</p>
</li>
<li>
<p>Ivar实际上是一个指向objc_ivar的指针，其具体定义为</p>
<pre><code class="language-c">typedef struct objc_ivar *Ivar;

struct objc_ivar
{
   char *ivar_name;
   char *ivar_type;
   int ivar_offset;
};
</code></pre>
<p>参见：http://mirror.informatimago.com/next/developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/9objc_runtime_reference/chapter_5_section_56.html</p>
</li>
</ul>
</blockquote>
<ol>
<li>
<p>成员变量操作函数，主要包含以下函数：</p>
<pre><code class="language-c">// 获取类中指定名称实例成员变量的信息
Ivar class_getInstanceVariable ( Class cls, const char *name );
// 获取类成员变量的信息
Ivar class_getClassVariable ( Class cls, const char *name );
// 添加成员变量
BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );
// 获取整个成员变量列表
Ivar * class_copyIvarList ( Class cls, unsigned int *outCount );
</code></pre>
<p>说明：</p>
<ul>
<li><code>class_getInstanceVariable</code>函数，它返回一个指向包含name指定的成员变量信息的<code>objc_ivar</code>结构体的指针(<code>Ivar</code>)。</li>
<li><code>class_getClassVariable</code>函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。</li>
<li>Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用<code>class_addIvar</code>函数了。不过需要注意的是，这个方法只能在<code>objc_allocateClassPair</code>函数与<code>objc_registerClassPair</code>之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是<code>1&lt;&lt;alignment</code>。这取决于<code>ivar</code>的类型和机器的架构。如果变量的类型是指针类型，则传递<code>log2(sizeof(pointer_type))</code>。</li>
<li><code>class_copyIvarList</code>函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的<code>objc_ivar</code>结构体的指针。这个数组不包含在父类中声明的变量。<code>outCount</code>指针返回数组的大小。需要注意的是，我们必须使用<code>free()</code>来释放这个数组。</li>
</ul>
</li>
<li>
<p>属性操作函数，主要包含以下函数：</p>
<pre><code class="language-c">// 获取指定的属性
objc_property_t class_getProperty ( Class cls, const char *name );
// 获取属性列表
objc_property_t * class_copyPropertyList ( Class cls, unsigned int *outCount );
// 为类添加属性
BOOL class_addProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );
// 替换类的属性
void class_replaceProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );
</code></pre>
<p>这一种方法也是针对<code>ivars</code>来操作，不过只操作那些是属性的值。我们在后面介绍属性时会再遇到这些函数。</p>
</li>
<li>
<p>在MAC OS X系统中，我们可以使用垃圾回收器。runtime提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理<code>strong/weak</code>引用。这几个函数定义如下：</p>
<pre><code class="language-c">const uint8_t * class_getIvarLayout ( Class cls );
void class_setIvarLayout ( Class cls, const uint8_t *layout );
const uint8_t * class_getWeakIvarLayout ( Class cls );
void class_setWeakIvarLayout ( Class cls, const uint8_t *layout );
</code></pre>
<p>但通常情况下，我们不需要去主动调用这些方法；在调用<code>objc_registerClassPair</code>时，会生成合理的布局。在此不详细介绍这些函数。</p>
</li>
</ol>
<h3 id="方法methodlists">方法(methodLists)</h3>
<p>方法操作主要有以下函数：</p>
<pre><code class="language-c">// 添加方法
BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );
// 获取实例方法
Method class_getInstanceMethod ( Class cls, SEL name );
// 获取类方法
Method class_getClassMethod ( Class cls, SEL name );
// 获取所有方法的数组
Method * class_copyMethodList ( Class cls, unsigned int *outCount );
// 替代方法的实现
IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );
// 返回方法的具体实现
IMP class_getMethodImplementation ( Class cls, SEL name );
IMP class_getMethodImplementation_stret ( Class cls, SEL name );
// 类实例是否响应指定的selector
BOOL class_respondsToSelector ( Class cls, SEL sel );
</code></pre>
<p>说明：</p>
<ul>
<li>
<p><code>class_addMethod</code>的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。如果要修改已存在实现，可以使用<code>method_setImplementation</code>。一个Objective-C方法是一个简单的C函数，它至少包含两个参数–<code>self</code>和<code>_cmd</code>。所以，我们的实现函数(IMP参数指向的函数)至少需要两个参数，如下所示：</p>
<pre><code class="language-c">void myMethodIMP(id self, SEL _cmd)
{
    // implementation ....
}
</code></pre>
<p>与成员变量不同的是，我们可以为类动态添加方法，不管这个类是否已存在。另外，参数<code>types</code>是一个描述传递给方法的参数类型的字符数组，这就涉及到类型编码，我们将在后面介绍。</p>
</li>
<li>
<p><code>class_getInstanceMethod</code>、<code>class_getClassMethod</code>函数，与<code>class_copyMethodList</code>不同的是，这两个函数都会去搜索父类的实现。</p>
</li>
<li>
<p><code>class_copyMethodList</code>函数，返回包含所有<mark>实例方法</mark>的数组，如果需要获取类方法，则可以使用<code>class_copyMethodList(object_getClass(cls), &amp;count)</code>(一个类的实例方法是定义在元类里面)。该列表不包含父类实现的方法。<code>outCount</code>参数返回方法的个数。在获取到列表后，我们需要使用<code>free()</code>方法来释放它。</p>
</li>
<li>
<p><code>class_replaceMethod</code>函数，该函数的行为可以分为两种：如果类中不存在name指定的方法，则类似于<code>class_addMethod</code>函数一样会添加方法；如果类中已存在name指定的方法，则类似于<code>method_setImplementation</code>一样替代原方法的实现。</p>
</li>
<li>
<p><code>class_getMethodImplementation</code>函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比<code>method_getImplementation(class_getInstanceMethod(cls, name))</code>更快。返回的函数指针可能是一个指向runtime内部的函数，而不一定是方法的实际实现。例如，如果类实例无法响应<code>selector</code>，则返回的函数指针将是运行时消息转发机制的一部分。</p>
</li>
<li>
<p><code>class_respondsToSelector</code>函数，我们通常使用NSObject类的<code>respondsToSelector:</code>或<code>instancesRespondToSelector:</code>方法来达到相同目的。</p>
</li>
</ul>
<h3 id="协议objc_protocol_list">协议(objc_protocol_list)</h3>
<p>协议相关的操作包含以下函数：</p>
<pre><code class="language-c">// 添加协议
BOOL class_addProtocol ( Class cls, Protocol *protocol );
// 返回类是否实现指定的协议
BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );
// 返回类实现的协议列表
Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount );
</code></pre>
<p>说明：</p>
<ul>
<li><code>class_conformsToProtocol</code>函数可以使用NSObject类的<code>conformsToProtocol:</code>方法来替代。</li>
<li><code>class_copyProtocolList</code>函数返回的是一个数组，在使用后我们需要使用<code>free()</code>手动释放。</li>
</ul>
<h3 id="版本version">版本(version)</h3>
<p>版本相关的操作包含以下函数：</p>
<pre><code class="language-c">// 获取版本号
int class_getVersion ( Class cls );
// 设置版本号
void class_setVersion ( Class cls, int version );
</code></pre>
<h3 id="其他">其他</h3>
<p>runtime还提供了两个函数来供<code>CoreFoundation</code>的<code>tool-free bridging</code>使用，即：</p>
<pre><code class="language-c">Class objc_getFutureClass ( const char *name );
void objc_setFutureClass ( Class cls, const char *name );
</code></pre>
<p>通常我们不直接使用这两个函数。</p>
<h3 id="实例example">实例(Example)</h3>
<p>上面列举了大量类操作的函数，下面我们写个实例，来看看这些函数的实例效果：</p>
<pre><code class="language-objc">//-----------------------------------------------------------
// MyClass.h
@interface MyClass : NSObject &lt;NSCopying, NSCoding&gt;
@property (nonatomic, strong) NSArray *array;
@property (nonatomic, copy) NSString *string;
- (void)method1;
- (void)method2;
+ (void)classMethod1;
@end
//-----------------------------------------------------------
// MyClass.m
#import &quot;MyClass.h&quot;
@interface MyClass () {
    NSInteger       _instance1;
    NSString    *   _instance2;
}
@property (nonatomic, assign) NSUInteger integer;
- (void)method3WithArg1:(NSInteger)arg1 arg2:(NSString *)arg2;
@end
@implementation MyClass
+ (void)classMethod1 {
}
- (void)method1 {
    NSLog(@&quot;call method method1&quot;);
}
- (void)method2 {
}
- (void)method3WithArg1:(NSInteger)arg1 arg2:(NSString *)arg2 {
    NSLog(@&quot;arg1 : %ld, arg2 : %@&quot;, arg1, arg2);
}
@end
//-----------------------------------------------------------
// main.h
#import &quot;MyClass.h&quot;
#import &quot;MySubClass.h&quot;
#import &lt;objc/runtime.h&gt;
int main(int argc, const char * argv[]) {
    @autoreleasepool {
    
        MyClass *myClass = [[MyClass alloc] init];
        unsigned int outCount = 0;
        Class cls = myClass.class;
        // 类名
        NSLog(@&quot;class name: %s&quot;, class_getName(cls));
        NSLog(@&quot;==========================================================&quot;);
        // 父类
        NSLog(@&quot;super class name: %s&quot;, class_getName(class_getSuperclass(cls)));
        NSLog(@&quot;==========================================================&quot;);
        // 是否是元类
        NSLog(@&quot;MyClass is %@ a meta-class&quot;, (class_isMetaClass(cls) ? @&quot;&quot; : @&quot;not&quot;));
        NSLog(@&quot;==========================================================&quot;);
      	// 上一个例子中使用objc_getClass()获取isa以获得meta class
        Class meta_class = objc_getMetaClass(class_getName(cls));
        NSLog(@&quot;%s's meta-class is %s&quot;, class_getName(cls), class_getName(meta_class));
        NSLog(@&quot;==========================================================&quot;);
        // 变量实例大小
        NSLog(@&quot;instance size: %zu&quot;, class_getInstanceSize(cls));
        NSLog(@&quot;==========================================================&quot;);
        // 成员变量
        Ivar *ivars = class_copyIvarList(cls, &amp;outCount);
        for (int i = 0; i &lt; outCount; i++) {
            Ivar ivar = ivars[i];
            NSLog(@&quot;instance variable's name: %s at index: %d&quot;, ivar_getName(ivar), i);
        }
        free(ivars);
        Ivar string = class_getInstanceVariable(cls, &quot;_string&quot;);
        if (string != NULL) {
            NSLog(@&quot;instace variable %s&quot;, ivar_getName(string));
        }
        NSLog(@&quot;==========================================================&quot;);
        // 属性操作
        objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);
        for (int i = 0; i &lt; outCount; i++) {
            objc_property_t property = properties[i];
            NSLog(@&quot;property's name: %s&quot;, property_getName(property));
        }
        free(properties);
        objc_property_t array = class_getProperty(cls, &quot;array&quot;);
        if (array != NULL) {
            NSLog(@&quot;property %s&quot;, property_getName(array));
        }
        NSLog(@&quot;==========================================================&quot;);
        // 方法操作
        Method *methods = class_copyMethodList(cls, &amp;outCount);
        for (int i = 0; i &lt; outCount; i++) {
            Method method = methods[i];
            NSLog(@&quot;method's signature: %s&quot;, method_getName(method));
        }
        free(methods);
        Method method1 = class_getInstanceMethod(cls, @selector(method1));
        if (method1 != NULL) {
            NSLog(@&quot;method %s&quot;, method_getName(method1));
        }
        Method classMethod = class_getClassMethod(cls, @selector(classMethod1));
        if (classMethod != NULL) {
            NSLog(@&quot;class method : %s&quot;, method_getName(classMethod));
        }
        NSLog(@&quot;MyClass is%@ responsd to selector: method3WithArg1:arg2:&quot;, class_respondsToSelector(cls, @selector(method3WithArg1:arg2:)) ? @&quot;&quot; : @&quot; not&quot;);
        IMP imp = class_getMethodImplementation(cls, @selector(method1));
        imp();
        NSLog(@&quot;==========================================================&quot;);
        // 协议
        Protocol * __unsafe_unretained * protocols = class_copyProtocolList(cls, &amp;outCount);
        Protocol * protocol;
        for (int i = 0; i &lt; outCount; i++) {
            protocol = protocols[i];
            NSLog(@&quot;protocol name: %s&quot;, protocol_getName(protocol));
        }
        NSLog(@&quot;MyClass is%@ responsed to protocol %s&quot;, class_conformsToProtocol(cls, protocol) ? @&quot;&quot; : @&quot; not&quot;, protocol_getName(protocol));
        NSLog(@&quot;==========================================================&quot;);
    }
    return 0;
}
</code></pre>
<p>这段程序的输出如下：</p>
<pre><code>2014-10-22 19:41:37.452 RuntimeTest[3189:156810] class name: MyClass
2014-10-22 19:41:37.453 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] super class name: NSObject
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass is not a meta-class
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass's meta-class is MyClass
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance size: 48
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _instance1 at index: 0
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _instance2 at index: 1
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _array at index: 2
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _string at index: 3
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instance variable's name: _integer at index: 4
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instace variable _string
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property's name: array
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property's name: string
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property's name: integer
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property array
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method1
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method2
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method3WithArg1:arg2:
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: integer
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setInteger:
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: array
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: string
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setString:
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setArray:
2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method's signature: .cxx_destruct
2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method method1
2014-10-22 19:41:37.466 RuntimeTest[3189:156810] class method : classMethod1
2014-10-22 19:41:37.466 RuntimeTest[3189:156810] MyClass is responsd to selector: method3WithArg1:arg2:
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] call method method1
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCopying
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCoding
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] MyClass is responsed to protocol NSCoding
2014-10-22 19:41:37.468 RuntimeTest[3189:156810] ==========================================================
</code></pre>
<h2 id="动态创建类和对象">动态创建类和对象</h2>
<p>runtime的强大之处在于它能在运行时创建类和对象。</p>
<h3 id="动态创建类">动态创建类</h3>
<p>动态创建类涉及到以下几个函数：</p>
<pre><code class="language-c">// 创建一个新类和元类
Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes );
// 销毁一个类及其相关联的类
void objc_disposeClassPair ( Class cls );
// 在应用中注册由objc_allocateClassPair创建的类
void objc_registerClassPair ( Class cls );
</code></pre>
<p>说明：</p>
<ul>
<li>
<p><code>objc_allocateClassPair</code>函数：如果我们要创建一个根类，则<code>superclass</code>指定为Nil。<code>extraBytes</code>通常指定为0，该参数是分配给类和元类对象尾部的索引<code>ivars</code>的字节数。</p>
<p>为了创建一个新类，我们需要调用<code>objc_allocateClassPair</code>。然后使用诸如<code>class_addMethod</code>，<code>class_addIvar</code>等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用<code>objc_registerClassPair</code>函数来注册类，之后这个新类就可以在程序中使用了。</p>
<p>实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</p>
</li>
<li>
<p><code>objc_disposeClassPair</code>函数用于销毁一个类，不过需要注意的是，如果程序运行中还存在类或其子类的实例，则不能调用针对类调用该方法。</p>
</li>
</ul>
<p>在前面介绍元类时，我们已经有接触到这几个函数了，在此我们再举个实例来看看这几个函数的使用。</p>
<pre><code class="language-objc">Class cls = objc_allocateClassPair(MyClass.class, &quot;MySubClass&quot;, 0);

// imp_submethod1是一个已实现的C语言方法，用于规定新建的submethod1和method1的行为
class_addMethod(cls, @selector(submethod1), (IMP)imp_submethod1, &quot;v@:&quot;);
class_replaceMethod(cls, @selector(method1), (IMP)imp_submethod1, &quot;v@:&quot;);
class_addIvar(cls, &quot;_ivar1&quot;, sizeof(NSString *), log(sizeof(NSString *)), &quot;i&quot;);

objc_property_attribute_t type = {&quot;T&quot;, &quot;@\&quot;NSString\&quot;&quot;};
objc_property_attribute_t ownership = { &quot;C&quot;, &quot;&quot; };
objc_property_attribute_t backingivar = { &quot;V&quot;, &quot;_ivar1&quot;};
objc_property_attribute_t attrs[] = {type, ownership, backingivar};

class_addProperty(cls, &quot;property2&quot;, attrs, 3);
objc_registerClassPair(cls);

id instance = [[cls alloc] init];
[instance performSelector:@selector(submethod1)];
[instance performSelector:@selector(method1)];
</code></pre>
<p>程序的输出如下：</p>
<pre><code>2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1
2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1
</code></pre>
<h3 id="动态创建对象">动态创建对象</h3>
<p>动态创建对象的函数如下：</p>
<pre><code class="language-c">// 创建类实例
id class_createInstance ( Class cls, size_t extraBytes );
// 在指定位置创建类实例
id objc_constructInstance ( Class cls, void *bytes );
// 销毁类实例
void * objc_destructInstance ( id obj );
</code></pre>
<p>说明：</p>
<ul>
<li>
<p><code>class_createInstance</code>函数：创建实例时，会在默认的内存区域为实例分配内存。<code>extraBytes</code>参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。<br>
调用<code>class_createInstance</code>的效果与<code>+alloc</code>方法类似。不过在使用<code>class_createInstance</code>时，我们需要确切的知道我们要用它来做什么。在下面的例子中，我们用NSString来测试一下该函数的实际效果：</p>
<pre><code class="language-objc">id theObject = class_createInstance(NSString.class, sizeof(unsigned));
 
id str1 = [theObject init];
NSLog(@&quot;%@&quot;, [str1 class]);
id str2 = [[NSString alloc] initWithString:@&quot;test&quot;];
NSLog(@&quot;%@&quot;, [str2 class]);
</code></pre>
<p>输出结果是：</p>
<pre><code>2014-10-23 12:46:50.781 RuntimeTest[4039:89088] NSString
2014-10-23 12:46:50.781 RuntimeTest[4039:89088] __NSCFConstantString
</code></pre>
<p>可以看到，使用<code>class_createInstance</code>函数获取的是NSString实例，而不是类簇中的默认占位符类<code>__NSCFConstantString</code>。</p>
</li>
<li>
<p><code>objc_constructInstance</code>函数：在指定的位置(bytes)创建类实例。</p>
</li>
<li>
<p><code>objc_destructInstance</code>函数：销毁一个类的实例，但不会释放并移除任何与其相关的引用。</p>
</li>
</ul>
<h3 id="实例操作函数">实例操作函数</h3>
<p>实例操作函数主要是针对我们创建的实例对象的一系列操作函数，我们可以使用这组函数来从实例对象中获取我们想要的一些信息，如实例对象中变量的值。这组函数可以分为三小类：</p>
<ol>
<li>
<p>针对整个对象进行操作的函数，这类函数包含</p>
<pre><code class="language-c">// 返回指定对象的一份拷贝
id object_copy ( id obj, size_t size );
// 释放指定对象占用的内存
id object_dispose ( id obj );
</code></pre>
<p>有这样一种场景，假设我们有类A和类B，且类B是类A的子类。类B通过添加一些额外的属性来扩展类A。现在我们创建了一个A类的实例对象，并希望在运行时将这个对象转换为B类的实例对象，这样可以添加数据到B类的属性中。这种情况下，我们没有办法直接转换，因为B类的实例会比A类的实例更大，没有足够的空间来放置对象。此时，我们就要以使用以上几个函数来处理这种情况，如下代码所示：</p>
<pre><code class="language-objc">// 在这个例子中类A是NSObject，类B是MyClass
// 创建NSObject类的子类
NSObject *a = [[NSObject alloc] init];
// 拷贝a到newB并且实例大小与MyClass相同
id newB = object_copy(a, class_getInstanceSize(MyClass.class));
// 赋予newB的类为MyClass
object_setClass(newB, MyClass.class);
// 释放a
object_dispose(a);
</code></pre>
</li>
<li>
<p>针对对象实例变量进行操作的函数，这类函数包含：</p>
<pre><code class="language-c">// 修改类实例的实例变量的值
Ivar object_setInstanceVariable ( id obj, const char *name, void *value );
// 获取对象实例变量的值
Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );
// 返回指向给定对象分配的任何额外字节的指针
void * object_getIndexedIvars ( id obj );
// 返回对象中实例变量的值
id object_getIvar ( id obj, Ivar ivar );
// 设置对象中实例变量的值
void object_setIvar ( id obj, Ivar ivar, id value );
</code></pre>
<p>如果实例变量的<code>Ivar</code>已经知道，那么调用<code>object_getIvar</code>会比<code>object_getInstanceVariable</code>函数快，相同情况下，<code>object_setIvar</code>也比<code>object_setInstanceVariable</code>快。</p>
</li>
<li>
<p>针对对象的类进行操作的函数，这类函数包含：</p>
<pre><code class="language-c">// 返回给定对象的类名
const char * object_getClassName ( id obj );
// 返回对象的类
Class object_getClass ( id obj );
// 设置对象的类
Class object_setClass ( id obj, Class cls );
</code></pre>
</li>
</ol>
<h3 id="获取类定义">获取类定义</h3>
<p>Objective-C动态运行库会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用<code>objc_addClass</code>函数来注册它们。<code>runtime</code>提供了一系列函数来获取类定义相关的信息，这些函数主要包括：</p>
<pre><code class="language-c">// 获取已注册的类定义的列表
int objc_getClassList ( Class *buffer, int bufferCount );
// 创建并返回一个指向所有已注册类的指针列表
Class* objc_copyClassList ( unsigned int *outCount );
// 返回指定类的类定义
Class objc_lookUpClass ( const char *name );
Class objc_getClass ( const char *name );
Class objc_getRequiredClass ( const char *name );
// 返回指定类的元类
Class objc_getMetaClass ( const char *name );
</code></pre>
<p>说明：</p>
<ul>
<li><code>objc_getClassList</code>函数：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现。</li>
</ul>
<blockquote>
<p>“我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现。” —— 为什么调用上面的方法需要检测在类中是否实现？</p>
</blockquote>
<p>下面代码演示了该函数的用法：</p>
<pre><code class="language-objc">int numClasses;
Class * classes = NULL;
// 首先检测已注册的类的数量是否大于0
numClasses = objc_getClassList(NULL, 0);
if (numClasses &gt; 0) {
    classes = malloc(sizeof(Class) * numClasses);
    numClasses = objc_getClassList(classes, numClasses);
    NSLog(@&quot;number of classes: %d&quot;, numClasses);
    for (int i = 0; i &lt; numClasses; i++) {
        Class cls = classes[i];
        NSLog(@&quot;class name: %s&quot;, class_getName(cls));
  }
    free(classes);
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>2014-10-23 16:20:52.589 RuntimeTest[8437:188589] number of classes: 1282
2014-10-23 16:20:52.589 RuntimeTest[8437:188589] class name: DDTokenRegexp
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: _NSMostCommonKoreanCharsKeySet
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: OS_xpc_dictionary
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: NSFileCoordinator
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: NSAssertionHandler
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: PFUbiquityTransactionLogMigrator
2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: NSNotification
2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: NSKeyValueNilSetEnumerator
2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: OS_tcp_connection_tls_session
2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: _PFRoutines
......还有大量输出
</code></pre>
<ul>
<li>
<p>获取类定义的方法有三个：<code>objc_lookUpClass</code>, <code>objc_getClass</code>和<code>objc_getRequiredClass</code>。如果类在运行时未注册，则<code>objc_lookUpClass</code>会返回nil，而<code>objc_getClass</code>会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。而<code>objc_getRequiredClass</code>函数的操作与<code>objc_getClass</code>相同，只不过如果没有找到类，则会杀死进程。</p>
</li>
<li>
<p><code>objc_getMetaClass</code>函数：如果指定的类没有注册，则该函数会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义，不管它是否有效。</p>
</li>
</ul>
<p>在前面一篇文章中，我们介绍了Runtime中与类和对象相关的内容，从这章开始，我们将讨论类实现细节相关的内容，主要包括类中成员变量，属性，方法，协议与分类的实现。</p>
<p>本章的主要内容将聚集在Runtime对成员变量与属性的处理。在讨论之前，我们先介绍一个重要的概念：类型编码。</p>
<h1 id="类型编码type-encoding">类型编码(Type Encoding)</h1>
<p>作为对Runtime的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的<code>selector</code>关联在一起。这种编码方案在其它情况下也是非常有用的，因此我们可以使用<code>@encode</code>编译器指令来获取它。当给定一个类型时，<code>@encode</code>返回这个类型的字符串编码。这些类型可以是诸如<code>int</code>、指针这样的基本类型，也可以是结构体、类等类型。事实上，任何可以作为<code>sizeof()</code>操作参数的类型都可以用于<code>@encode()</code>。</p>
<p>在<code>Objective-C Runtime Programming Guide</code>中的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding</a>一节中，列出了Objective-C中所有的类型编码。需要注意的是这些类型很多是与我们用于存档和分发的编码类型是相同的。但有一些不能在存档时使用。</p>
<p><em>注：Objective-C不支持long double类型。@encode(long double)返回d，与double是一样的。</em></p>
<p>一个数组的类型编码位于方括号中；其中包含数组元素的个数及元素类型。如以下示例：</p>
<pre><code class="language-objc">float a[] = {1.0, 2.0, 3.0};
NSLog(@&quot;array encoding type: %s&quot;, @encode(typeof(a)));
</code></pre>
<p>输出是：</p>
<pre><code>2014-10-28 11:44:54.731 RuntimeTest[942:50791] array encoding type: [3f]
</code></pre>
<p>其它类型可参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding</a>，在此不细说。</p>
<p>另外，还有些编码类型，<code>@encode</code>虽然不会直接返回它们，但它们可以作为协议中声明的方法的类型限定符。可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding</a>。</p>
<p>对于属性而言，还会有一些特殊的类型编码，以表明属性是只读、拷贝、<code>retain</code>等等，详情可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6">Property Type String</a>。</p>
<h1 id="成员变量-属性">成员变量、属性</h1>
<p>Runtime中关于成员变量和属性的相关数据结构并不多，只有三个，并且都很简单。不过还有个非常实用但可能经常被忽视的特性，即关联对象，我们将在这小节中详细讨论。</p>
<h2 id="基础数据类型">基础数据类型</h2>
<h3 id="ivar">Ivar</h3>
<p><code>Ivar</code>是表示实例变量的类型，其实际是一个指向<code>objc_ivar</code>结构体的指针，其定义如下：</p>
<pre><code class="language-c">typedef struct objc_ivar *Ivar;
struct objc_ivar {
    char *ivar_name               OBJC2_UNAVAILABLE;	// 变量名
    char *ivar_type             	OBJC2_UNAVAILABLE;	// 变量类型
    int ivar_offset            		OBJC2_UNAVAILABLE;	// 基地址偏移字节
#ifdef __LP64__
    int space                 		OBJC2_UNAVAILABLE;
#endif
}
</code></pre>
<h3 id="objc_property_t">objc_property_t</h3>
<p><code>objc_property_t</code>是表示Objective-C声明的属性的类型，其实际是指向<code>objc_property</code>结构体的指针，其定义如下：</p>
<pre><code class="language-c">typedef struct objc_property *objc_property_t;
</code></pre>
<h3 id="objc_property_attribute_t">objc_property_attribute_t</h3>
<p><code>objc_property_attribute_t</code>定义了属性的特性(<code>attribute</code>)，它是一个结构体，定义如下：</p>
<pre><code class="language-c">typedef struct {
    const char *name;           // 特性名
    const char *value;          // 特性值
} objc_property_attribute_t;
</code></pre>
<h2 id="关联对象associated-object">关联对象(Associated Object)</h2>
<p>关联对象是Runtime中一个非常实用的特性，不过可能很容易被忽视。</p>
<p>关联对象类似于成员变量，不过是在运行时添加的。我们通常会把成员变量(<code>Ivar</code>)放在类声明的头文件中，或者放在类实现的<code>@implementation</code>后面。但这有一个缺点，<mark>我们不能在分类中添加成员变量。如果我们尝试在分类中添加新的成员变量</mark>，编译器会报错。</p>
<p>我们可能希望通过使用(甚至是滥用)全局变量来解决这个问题。但这些都不是<code>Ivar</code>，因为他们不会连接到一个单独的实例。因此，这种方法很少使用。</p>
<p>Objective-C针对这一问题，提供了一个解决方案：即关联对象(<code>Associated Object</code>)。</p>
<p>我们可以把关联对象想象成一个Objective-C对象(如字典)，这个对象通过给定的key连接到类的一个实例上。不过由于使用的是C接口，所以key是一个<code>void</code>指针(<code>const void *</code>)。我们还需要指定一个内存管理策略，以告诉<code>Runtime</code>如何管理这个对象的内存。这个内存管理的策略可以由以下值指定：</p>
<pre><code>OBJC_ASSOCIATION_ASSIGN
OBJC_ASSOCIATION_RETAIN_NONATOMIC
OBJC_ASSOCIATION_COPY_NONATOMIC
OBJC_ASSOCIATION_RETAIN
OBJC_ASSOCIATION_COPY
</code></pre>
<p>当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象。如果指定的策略是<code>assign</code>，则宿主释放时，关联对象不会被释放；而如果指定的是<code>retain</code>或者是<code>copy</code>，则宿主释放时，关联对象会被释放。我们甚至可以选择是否是自动<code>retain/copy</code>。当我们需要在多个线程中处理访问关联对象的多线程代码时，这就非常有用了。</p>
<p>我们将一个对象连接到其它对象所需要做的就是下面两行代码：</p>
<pre><code class="language-c">static char myKey;
objc_setAssociatedObject(self, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);
</code></pre>
<p>在这种情况下，<code>self</code>对象将获取一个新的关联的对象<code>anObject</code>，且内存管理策略是自动<code>retain</code>关联对象，当<code>self</code>对象释放时，会自动<code>release</code>关联对象。另外，如果我们使用同一个key来关联另外一个对象时，也会自动释放之前关联的对象，这种情况下，先前的关联对象会被妥善地处理掉，并且新的对象会使用它的内存。</p>
<pre><code class="language-c">id anObject = objc_getAssociatedObject(self, &amp;myKey);
</code></pre>
<p>我们可以使用<code>objc_removeAssociatedObjects</code>函数来移除一个关联对象，或者使用<code>objc_setAssociatedObject</code>函数将key指定的关联对象设置为nil。</p>
<p>我们下面来用实例演示一下关联对象的使用方法。</p>
<p>假定我们想要动态地将一个Tap手势操作连接到任何<code>UIView</code>中，并且根据需要指定点击后的实际操作。这时候我们就可以将一个手势对象及操作的block对象关联到我们的<code>UIView</code>对象中。这项任务分两部分。首先，如果需要，我们要创建一个手势识别对象并将它及block做为关联对象。如下代码所示：</p>
<pre><code class="language-objc">- (void)setTapActionWithBlock:(void (^)(void))block
{
	UITapGestureRecognizer *gesture = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey);
 
	if (!gesture)
	{
		gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(__handleActionForTapGesture:)];
		[self addGestureRecognizer:gesture];
		objc_setAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);
	}
	objc_setAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);
}
</code></pre>
<p>这段代码检测了手势识别的关联对象。如果没有，则创建并建立关联关系。同时，将传入的块对象连接到指定的key上。注意<code>block</code>对象的关联内存管理策略。<br>
手势识别对象需要一个<code>target</code>和<code>action</code>，所以接下来我们定义处理方法：</p>
<pre><code class="language-objc">- (void)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture
{
	if (gesture.state == UIGestureRecognizerStateRecognized)
	{
		void(^action)(void) = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey);
		if (action)
		{
			action();
		}
	}
}
</code></pre>
<p>我们需要检测手势识别对象的状态，因为我们只需要在点击手势被识别出来时才执行操作。</p>
<p>从上面的例子我们可以看到，关联对象使用起来并不复杂。它让我们可以动态地增强类现有的功能。我们可以在实际编码中灵活地运用这一特性。</p>
<h2 id="成员变量-属性的操作方法">成员变量、属性的操作方法</h2>
<p>在Objective-C 1.0中需要同时声明属性和成员变量：</p>
<pre><code class="language-objc">@interface MyViewController :UIViewController {
    UIButton *myButton; // 成员变量
}
@property (nonatomic, retain) UIButton *myButton; // 属性
@end
</code></pre>
<p>在Objective-C 2.0中，<code>@property</code>它将自动创建一个以下划线开头的成员变量。因此，在这个版本中，我们不再为interface声明实例变量:</p>
<pre><code class="language-objc">@interface MyViewController :UIViewController
@property (nonatomic, retain) UIButton *myButton;
@end
</code></pre>
<h3 id="成员变量">成员变量</h3>
<p>成员变量操作包含以下函数：</p>
<pre><code class="language-c">// 获取成员变量名
const char * ivar_getName ( Ivar v );
// 获取成员变量类型编码
const char * ivar_getTypeEncoding ( Ivar v );
// 获取成员变量的偏移量
ptrdiff_t ivar_getOffset ( Ivar v );
</code></pre>
<p>说明：</p>
<ul>
<li><code>ivar_getOffset</code>函数，对于类型<code>id</code>或其它对象类型的实例变量，可以调用<code>object_getIvar</code>和<code>object_setIvar</code>来直接访问成员变量，而不使用偏移量。</li>
</ul>
<h3 id="关联对象">关联对象</h3>
<p>关联对象操作函数包括以下：</p>
<pre><code class="language-objc">// 设置关联对象
void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );
// 获取关联对象
id objc_getAssociatedObject ( id object, const void *key );
// 移除关联对象
void objc_removeAssociatedObjects ( id object );
</code></pre>
<p>关联对象及相关实例已经在前面讨论过了，在此不再重复。</p>
<h3 id="属性">属性</h3>
<p>属性操作相关函数包括以下：</p>
<pre><code class="language-c">// 获取属性名
const char * property_getName ( objc_property_t property );
// 获取属性特性描述字符串
const char * property_getAttributes ( objc_property_t property );
// 获取属性中指定的特性
char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );
// 获取属性的特性列表
objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount );
</code></pre>
<p>说明：</p>
<ul>
<li><code>property_copyAttributeValue</code>函数，返回的<code>char *</code>在使用完后需要调用<code>free()</code>释放。</li>
<li><code>property_copyAttributeList</code>函数，返回值在使用完后需要调用<code>free()</code>释放。</li>
</ul>
<h1 id="实例">实例</h1>
<p>假定这样一个场景，我们从服务端两个不同的接口获取相同的字典数据，但这两个接口是由两个人写的，相同的信息使用了不同的字段表示。我们在接收到数据时，可将这些数据保存在相同的对象中。对象类如下定义：</p>
<pre><code class="language-objc">// MyObject.h
#import &lt;Foundation/Foundation.h&gt;

NS_ASSUME_NONNULL_BEGIN

@interface MyObject : NSObject

@property (nonatomic, copy) NSString *name;
@property (nonatomic, copy) NSString *status;

- (NSString *)propertyForKey: (NSString *)key;
- (void)setDataWithDic:(NSDictionary *)dic;

@end

NS_ASSUME_NONNULL_END
</code></pre>
<p>接口A、B返回的字典数据如下所示：</p>
<pre><code class="language-objc">@{@&quot;name1&quot;: @&quot;张三&quot;, @&quot;status1&quot;: @&quot;start&quot;}
@{@&quot;name2&quot;: @&quot;张三&quot;, @&quot;status2&quot;: @&quot;end&quot;}
</code></pre>
<p>通常的方法是写两个方法分别做转换，不过如果能灵活地运用Runtime的话，可以只实现一个转换方法，为此，我们需要先定义一个映射字典(全局变量)</p>
<pre><code class="language-objc">// MyObject.m
#import &quot;MyObject.h&quot;
#import &lt;objc/runtime.h&gt;

static NSMutableDictionary *map = nil;

@implementation MyObject

+ (void)load {
    map = [NSMutableDictionary dictionary];
    map[@&quot;name1&quot;] = @&quot;name&quot;;
    map[@&quot;status1&quot;] = @&quot;status&quot;;
    map[@&quot;name2&quot;] = @&quot;name&quot;;
    map[@&quot;status2&quot;] = @&quot;status&quot;;
}

- (NSString *)propertyForKey:(NSString *)key {
    if (map == nil) {
        [MyObject load];
    }
    return map[key];
}

// 上面的代码将两个字典中不同的字段映射到MyObject中相同的属性上，这样，转换方法可如下处理
- (void)setDataWithDic:(NSDictionary *)dic {
    [dic enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) {
        NSString *propertyKey = [self propertyForKey: key];
        NSLog(@&quot;propertyKey: %@&quot;, propertyKey);
        
        if (propertyKey) {
            objc_property_t property = class_getProperty([self class], [propertyKey UTF8String]);
            NSString *attributeString = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];
            NSLog(@&quot;attributeString: %@&quot;, attributeString);
            // ...
            [self setValue:obj forKey:propertyKey];
        }
    }];
}

@end
</code></pre>
<p>当然，一个属性能否通过上面这种方式来处理的前提是其支持KVC。Main函数：</p>
<pre><code class="language-objc">// main.m
#import &lt;Foundation/Foundation.h&gt;
#import &quot;MyObject.h&quot;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        MyObject *myObject = [[MyObject alloc] init];
        [myObject setDataWithDic:@{@&quot;name1&quot;: @&quot;张三&quot;, @&quot;status1&quot;: @&quot;start&quot;}];
        // load data from myObject
        NSLog(@&quot;myObject name: %@, status: %@&quot;, myObject.name, myObject.status);
    }
    return 0;
}
</code></pre>
<p>输出结果</p>
<pre><code>2020-03-04 17:22:11.173 ObjectiveCRuntime[7550:133211] propertyKey: name
2020-03-04 17:22:11.173 ObjectiveCRuntime[7550:133211] attributeString: T@&quot;NSString&quot;,C,N,V_name
2020-03-04 17:22:11.173 ObjectiveCRuntime[7550:133211] propertyKey: status
2020-03-04 17:22:11.173 ObjectiveCRuntime[7550:133211] attributeString: T@&quot;NSString&quot;,C,N,V_status
2020-03-04 17:22:11.173 ObjectiveCRuntime[7550:133211] myObject name: 张三, status: start
</code></pre>
<p>前面我们讨论了Runtime中对类和对象的处理，及对成员变量与属性的处理。这一章，我们就要开始讨论Runtime中最有意思的一部分：消息处理机制。我们将详细讨论消息的发送及消息的转发。不过在讨论消息之前，我们先来了解一下与方法相关的一些内容。</p>
<h1 id="基础数据类型-2">基础数据类型</h1>
<h2 id="sel">SEL</h2>
<p>SEL又叫选择器，是表示一个方法的<code>selector</code>的指针，其定义如下：</p>
<pre><code class="language-c">typedef struct objc_selector *SEL;
</code></pre>
<p><code>objc_selector</code>结构体的详细定义没有在<code>&lt;objc/runtime.h&gt;</code>头文件中找到。方法的<code>selector</code>用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(<code>Int</code>类型的地址)，这个标识就是<code>SEL</code>。如下代码所示：</p>
<pre><code class="language-objc">SEL sel1 = @selector(method1);
NSLog(@&quot;sel : %p&quot;, sel1);
</code></pre>
<p>上面的输出为：</p>
<pre><code>	2014-10-30 18:40:07.518 RuntimeTest[52734:466626] sel : 0x100002d72
</code></pre>
<p>两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的SEL就是一样的。每一个方法都对应着一个<code>SEL</code>。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个<code>SEL</code>。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法的能力很差。如在某个类中定义以下两个方法：</p>
<pre><code class="language-objc">- (void)setWidth:(int)width;
- (void)setWidth:(double)width;
</code></pre>
<p>这样的定义被认为是一种编译错误，所以我们不能像C++, C#那样。而是需要像下面这样来声明：</p>
<pre><code class="language-objc">-(void)setWidthIntValue:(int)width;
-(void)setWidthDoubleValue:(double)width;
</code></pre>
<p>当然，不同的类可以拥有相同的<code>selector</code>，这个没有问题。不同类的实例对象执行相同的<code>selector</code>时，会在各自的方法列表中去根据<code>selector</code>去寻找自己对应的<code>IMP</code>。</p>
<p>工程中的所有的<code>SEL</code>组成一个<code>Set</code>集合，Set的特点就是唯一，因此SEL是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名<code>hash</code>化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！！但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是<code>perfect hash</code>）。但是不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个<code>SEL</code>），那将是最犀利的方法。那么，我们就不难理解，为什么<code>SEL</code>仅仅是函数名了。</p>
<p>本质上，<code>SEL</code>只是一个指向方法的指针（准确的说，只是一个根据方法名<code>hash</code>化了的<code>KEY</code>值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。</p>
<p>我们可以在运行时添加新的<code>selector</code>，也可以在运行时获取已存在的<code>selector</code>，我们可以通过下面三种方法来获取SEL:</p>
<ul>
<li><code>sel_registerName</code>函数</li>
<li>Objective-C编译器提供的<code>@selector()</code></li>
<li><code>NSSelectorFromString()</code>方法</li>
</ul>
<h2 id="imp">IMP</h2>
<p><code>IMP</code>实际上是一个函数指针，指向方法实现的首地址。其定义如下：</p>
<pre><code class="language-c">id (*IMP)(id, SEL, ...)
</code></pre>
<p>这个函数使用当前<code>CPU</code>架构实现的标准的C调用约定。<mark>第一个参数是指向<code>self</code>的指针</mark>(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，<mark>第二个参数是方法选择器(<code>selector</code>)，接下来是方法的实际参数列表。</mark></p>
<p>前面介绍过的<code>SEL</code>就是为了查找方法的最终实现<code>IMP</code>的。由于每个方法对应唯一的<code>SEL</code>，因此我们可以通过<code>SEL</code>方便快速准确地获得它所对应的<code>IMP</code>，查找过程将在下面讨论。取得<code>IMP</code>后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p>
<p>通过取得<code>IMP</code>，我们可以跳过Runtime的消息传递机制，直接执行<code>IMP</code>指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</p>
<h2 id="method">Method</h2>
<p>介绍完<code>SEL</code>和<code>IMP</code>，我们就可以来讲讲<code>Method</code>了。<code>Method</code>用于表示类定义中的方法，则定义如下：</p>
<pre><code class="language-c">typedef struct objc_method *Method;

struct objc_method {
    SEL method_name                	OBJC2_UNAVAILABLE;	// 方法名
    char *method_types              OBJC2_UNAVAILABLE;
    IMP method_imp             			OBJC2_UNAVAILABLE;	// 方法实现
}
</code></pre>
<p>我们可以看到该结构体中包含一个<code>SEL</code>和<code>IMP</code>，实际上相当于在<code>SEL</code>和<code>IMP</code>之间作了一个映射。有了SEL，我们便可以找到对应的<code>IMP</code>，从而调用方法的实现代码。具体操作流程我们将在下面讨论。</p>
<h3 id="objc_method_description">objc_method_description</h3>
<p><code>objc_method_description</code>定义了一个Objective-C方法，其定义如下：</p>
<pre><code class="language-c">struct objc_method_description { SEL name; char *types; };
</code></pre>
<p>说明：</p>
<ul>
<li>types是方法返回类型，</li>
</ul>
<h1 id="方法相关操作函数">方法相关操作函数</h1>
<p>Runtime提供了一系列的方法来处理与方法相关的操作。包括方法本身及SEL。本节我们介绍一下这些函数。</p>
<h2 id="方法">方法</h2>
<p>方法操作相关函数包括下以：</p>
<pre><code class="language-c">// 调用指定方法的实现
id method_invoke ( id receiver, Method m, ... );
// 调用返回一个数据结构的方法的实现
void method_invoke_stret ( id receiver, Method m, ... );
// 获取方法名
SEL method_getName ( Method m );
// 返回方法的实现
IMP method_getImplementation ( Method m );
// 获取描述方法参数和返回值类型的字符串
const char * method_getTypeEncoding ( Method m );
// 获取方法的返回值类型的字符串
char * method_copyReturnType ( Method m );
// 获取方法的指定位置参数的类型字符串
char * method_copyArgumentType ( Method m, unsigned int index );
// 通过引用返回方法的返回值类型字符串
void method_getReturnType ( Method m, char *dst, size_t dst_len );
// 返回方法的参数的个数
unsigned int method_getNumberOfArguments ( Method m );
// 通过引用返回方法指定位置参数的类型字符串
void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );
// 返回指定方法的方法描述结构体
struct objc_method_description * method_getDescription ( Method m );
// 设置方法的实现
IMP method_setImplementation ( Method m, IMP imp );
// 交换两个方法的实现
void method_exchangeImplementations ( Method m1, Method m2 );
</code></pre>
<p>说明：</p>
<ul>
<li><code>method_invoke</code>函数，返回的是实际实现的返回值。参数<code>receiver</code>不能为空。这个方法的效率会比<code>method_getImplementation</code>和<code>method_getName</code>更快。</li>
<li><code>method_getName</code>函数，返回的是一个<code>SEL</code>。如果想获取方法名的C字符串，可以使用<code>sel_getName(method_getName(method))</code>。</li>
<li><code>method_getReturnType</code>函数，类型字符串会被拷贝到<code>dst</code>中。</li>
<li><code>method_setImplementation</code>函数，注意该函数返回值是方法之前的实现。</li>
</ul>
<h2 id="方法选择器">方法选择器</h2>
<p>选择器相关的操作函数包括：</p>
<pre><code class="language-c">// 返回给定选择器指定的方法的名称
const char * sel_getName ( SEL sel );
// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器
SEL sel_registerName ( const char *str );
// 在Objective-C Runtime系统中注册一个方法
SEL sel_getUid ( const char *str );
// 比较两个选择器
BOOL sel_isEqual ( SEL lhs, SEL rhs );
</code></pre>
<p>说明：</p>
<ul>
<li><code>sel_registerName</code>函数：在我们将一个方法添加到类定义时，我们必须在Objective-C Runtime系统中注册一个方法名以获取方法的选择器。</li>
</ul>
<h1 id="方法调用流程">方法调用流程</h1>
<p>在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式<code>[receiver message]</code>转化为一个消息函数的调用，即<code>objc_msgSend</code>。这个函数将消息接收者和方法名作为其基础参数，如以下所示：</p>
<pre><code class="language-c">objc_msgSend(receiver, selector)
</code></pre>
<p>如果消息中还有其它参数，则该方法的形式如下所示：</p>
<pre><code class="language-c">objc_msgSend(receiver, selector, arg1, arg2, ...)
</code></pre>
<p>这个函数完成了动态绑定的所有事情：</p>
<ol>
<li>首先它找到<code>selector</code>对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现。</li>
<li>它调用方法实现，并将接收者对象及方法的所有参数传给它。</li>
<li>最后，它将实现返回的值作为它自己的返回值。</li>
</ol>
<p>消息的关键在于我们前面章节讨论过的结构体<code>objc_class</code>，这个结构体有两个字段是我们在分发消息的关注的：</p>
<ol>
<li>指向父类的指针</li>
<li>一个类的方法分发表，即<code>methodLists</code>。</li>
</ol>
<p>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系。</p>
<p>下图演示了这样一个消息的基本框架：</p>
<figure data-type="image" tabindex="2"><img src="http://res.niuxuewei.com/2020-03-05-041737.gif" alt="messaging1" loading="lazy"></figure>
<p>当消息发送给一个对象时，<code>objc_msgSend</code>通过对象的<code>isa</code>指针获取到类的结构体，然后在方法分发表里面查找方法的<code>selector</code>。如果没有找到<code>selector</code>，则通过<code>objc_msgSend</code>结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的<code>selector</code>。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到<code>selector</code>，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到<code>selector</code>，则会走消息转发流程，这个我们在后面讨论。</p>
<p>为了加速消息的处理，运行时系统缓存使用过的<code>selector</code>及对应的方法的地址。这点我们在<a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/">前面</a>讨论过，不再重复。</p>
<h2 id="隐藏参数">隐藏参数</h2>
<p><code>objc_msgSend</code>有两个隐藏参数：</p>
<ol>
<li>消息接收对象</li>
<li>方法的selector</li>
</ol>
<p>这两个参数为方法的实现提供了调用者的信息。之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明。它们是在编译期被插入实现代码的。</p>
<p>虽然这些参数没有显示声明，但在代码中仍然可以引用它们。我们可以使用<code>self</code>来引用接收者对象，使用<code>_cmd</code>来引用选择器。如下代码所示：</p>
<pre><code class="language-objc">- strange
{
    id  target = getTheReceiver();
    SEL method = getTheMethod();

    if ( target == self || method == _cmd )
        return nil;

    return [target performSelector:method];
}
</code></pre>
<p>当然，这两个参数我们用得比较多的是<code>self</code>，<code>_cmd</code>在实际中用得比较少。</p>
<h2 id="获取方法地址">获取方法地址</h2>
<p>Runtime中方法的动态绑定让我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来得那么直接。当然，方法的缓存一定程度上解决了这一问题。</p>
<p>我们上面提到过，如果想要避开这种动态绑定方式，我们可以获取方法实现的地址，然后像调用函数一样来直接调用它。特别是当我们需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。</p>
<p>NSObject类提供了<code>methodForSelector:</code>方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将<code>methodForSelector:</code>返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。</p>
<p>我们通过以下代码来看看<code>methodForSelector:</code>的使用：</p>
<pre><code class="language-objc">void (*setter)(id, SEL, BOOL);
int i;

setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];

for (i = 0 ; i &lt; 1000 ; i++)
    setter(targetList[i], @selector(setFilled:), YES);
</code></pre>
<p>这里需要注意的就是函数指针的前两个参数必须是<code>id</code>和<code>SEL</code>。</p>
<p>当然这种方式只适合于在类似于<code>for</code>循环这种情况下频繁调用同一方法，以提高性能的情况。另外，<code>methodForSelector:</code>是由Cocoa运行时提供的；它不是Objective-C语言的特性。</p>
<h1 id="消息转发">消息转发</h1>
<p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以<code>[object message]</code>的方式调用方法，如果<code>object</code>无法响应<code>message</code>消息时，编译器会报错。但如果是以<code>perform...</code>的形式来调用，则需要等到运行时才能确定object是否能接收<code>message</code>消息。如果不能，则程序崩溃。</p>
<p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用<code>respondsToSelector:</code>来判断一下。如下代码所示：</p>
<pre><code class="language-objc">if ([self respondsToSelector:@selector(method)]) {
    [self performSelector:@selector(method)];
}
</code></pre>
<p>不过，我们这边想讨论下不使用<code>respondsToSelector:</code>判断的情况。这才是我们这一节的重点。</p>
<p>当一个对象无法接收某一消息时，就会启动所谓**消息转发(message forwarding)**机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：</p>
<pre><code>-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940

*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940'
</code></pre>
<p>这段异常信息实际上是由NSObject的<code>doesNotRecognizeSelector</code>方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p>
<p>消息转发机制基本上分为三个步骤：</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ol>
<p>下面我们详细讨论一下这三个步骤。</p>
<h2 id="动态方法解析">动态方法解析</h2>
<p>对象在接收到未知的消息时，首先会调用所属类的类方法<code>+resolveInstanceMethod:</code>(实例方法)或者<code>+resolveClassMethod:</code>(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过<code>class_addMethod</code>函数动态添加到类里面就可以了。如下代码所示：</p>
<pre><code class="language-objc">void functionForMethod1(id self, SEL _cmd) {
   NSLog(@&quot;%@, %p&quot;, self, _cmd);
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {

    NSString *selectorString = NSStringFromSelector(sel);
    if ([selectorString isEqualToString:@&quot;method1&quot;]) {
        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);
    }

    return [super resolveInstanceMethod:sel];
}

// call method1 by performSelector
[self performSelector:@selector(method1)]
</code></pre>
<p>不过这种方案更多的是为了实现<code>@dynamic</code>属性。</p>
<h2 id="备用接收者">备用接收者</h2>
<p>如果在上一步无法处理消息，则Runtime会继续调以下方法：</p>
<pre><code class="language-objc">- (id)forwardingTargetForSelector:(SEL)aSelector
</code></pre>
<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是<code>self</code>自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理<code>aSelector</code>，则应该调用父类的实现来返回结果。</p>
<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示：</p>
<pre><code class="language-objc">// SUTRuntimeMethod.h
#import &lt;Foundation/Foundation.h&gt;

@interface SUTRuntimeMethod : NSObject

+ (instancetype)object;
- (void)test;

@end
</code></pre>
<pre><code class="language-objc">// SUTRuntimeMethod.m
#import &quot;SUTRuntimeMethod.h&quot;


@interface SUTRuntimeMethodHelper: NSObject

- (void)method2;

@end

@implementation SUTRuntimeMethodHelper

- (void)method2 {
    NSLog(@&quot;self: %@, sel: %p&quot;, self, _cmd);
}

@end

#pragma mark - SUTRuntimeMethod

@interface SUTRuntimeMethod () {
    SUTRuntimeMethodHelper *_helper;
}
@end

@implementation SUTRuntimeMethod

+ (instancetype)object {
    return [[self alloc] init];
}

- (instancetype)init {
    self = [super init];
    if (self != nil) {
        _helper = [[SUTRuntimeMethodHelper alloc] init];
    }
    return self;
}

- (void)test {
    [self performSelector:@selector(method2)];
}

- (id)forwardingTargetForSelector:(SEL)aSelector {
    NSLog(@&quot;forwardingTargetForSelector&quot;);

    NSString *selectorString = NSStringFromSelector(aSelector);
    if ([selectorString isEqualToString:@&quot;method2&quot;]) {
        return _helper;
    }

    return [super forwardingTargetForSelector:aSelector];
}

@end
</code></pre>
<pre><code class="language-objc">// main.m
#import &lt;Foundation/Foundation.h&gt;
#import &quot;SUTRuntimeMethod.h&quot;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        SUTRuntimeMethod *method = [SUTRuntimeMethod object];
        [method test];
    }
    return 0;
}
</code></pre>
<p>输出结果</p>
<pre><code>2020-03-05 19:20:58.197 ObjectiveCRuntime[74801:331213] forwardingTargetForSelector
2020-03-05 19:20:58.198 ObjectiveCRuntime[74801:331213] self: &lt;SUTRuntimeMethodHelper: 0x7fa04bd04ed0&gt;, sel: 0x100d3eeba
</code></pre>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h2 id="完整消息转发">完整消息转发</h2>
<p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：</p>
<pre><code class="language-objc">- (void)forwardInvocation:(NSInvocation *)anInvocation
</code></pre>
<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。==对象会创建一个表示消息的<code>NSInvocation</code>对象，把与尚未处理的消息有关的全部细节都封装在<code>anInvocation</code>中，包括<code>selector</code>，目标(<code>target</code>)和参数。==我们可以在<code>forwardInvocation</code>方法中选择将消息转发给其它对象。</p>
<p><code>forwardInvocation:</code>方法的实现有两个任务：</p>
<ol>
<li>定位可以响应封装在<code>anInvocation</code>中的消息的对象。这个对象不需要能处理所有未知消息。</li>
<li>使用<code>anInvocation</code>作为参数，将消息发送到选中的对象。<code>anInvocation</code>将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ol>
<p>不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p>
<p>还有一个很重要的问题，我们必须重写以下方法：</p>
<pre><code class="language-objc">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
</code></pre>
<p>消息转发机制使用从这个方法中获取的信息来创建<code>NSInvocation</code>对象。因此我们必须重写这个方法，为给定的<code>selector</code>提供一个合适的方法签名。</p>
<p>完整的示例如下所示：</p>
<pre><code class="language-objc">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {

    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];
    if (!signature) {
        if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) {
            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];
        }
    }

    return signature;
}

- (void)forwardInvocation:(NSInvocation *)anInvocation {
    if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) {
        [anInvocation invokeWithTarget:_helper];
    }
}
</code></pre>
<p>NSObject的<code>forwardInvocation:</code>方法实现只是简单调用了<code>doesNotRecognizeSelector:</code>方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>
<p>从某种意义上来讲，<code>forwardInvocation:</code>就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。</p>
<h2 id="消息转发与多重继承">消息转发与多重继承</h2>
<p>回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。</p>
<p>不过消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者。如<code>respondsToSelector:</code>和<code>isKindOfClass:</code>只能用于继承体系，而不能用于转发链。便如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：</p>
<pre><code class="language-objc">- (BOOL)respondsToSelector:(SEL)aSelector
{
	if ( [super respondsToSelector:aSelector])
		return YES;
	else {
		/* Here, test whether the aSelector message can     *
		 * be forwarded to another object and whether that  *
		 * object can respond to it. Return YES if it can.  */
	}

	return NO; 	
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker Usage]]></title>
        <id>https://www.nxw.name/post/docker-usage/</id>
        <link href="https://www.nxw.name/post/docker-usage/">
        </link>
        <updated>2020-02-28T09:58:48.000Z</updated>
        <summary type="html"><![CDATA[<p>Docker is a set of platform as a service products that uses OS-level virtualization to deliver software in packages called containers.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Docker is a set of platform as a service products that uses OS-level virtualization to deliver software in packages called containers.</p>
<!-- more -->
<h1 id="installation">Installation</h1>
<p>In most cases, you can use a shell provided by docker official to install docker on your server.</p>
<pre><code class="language-bash">wget -qO- https://get.docker.com/ | bash
</code></pre>
<p>Then, you should open it and ensure the docker will be launched after login.</p>
<pre><code class="language-bash"># for Debian &amp; Ubuntu
systemctl start docker

# for CentOS
service docker start &amp;&amp; systemctl enable docker.service
</code></pre>
<h1 id="image-update">Image Update</h1>
<p>To update your image you should pull the latest image from Docker Hub, destory the running container and recreate it with the new image. The data may be lost if you have not persisted them on your disk.</p>
<pre><code class="language-bash">docker pull &lt;DOCKER HUB COORDINATE&gt;

docker stop &lt;YOUR CONTAINER NAME&gt; &amp;&amp; docker rm &lt;YOUR CONTAINER NAME&gt;

docker run ...
</code></pre>
<h1 id="development">Development</h1>
<p>If you want to build Dockerfile by yourself and push your image to Docker Hub, I highly recommend you develop in local and push them by Github Actions which is a solution for CD/CI proposed by Github.</p>
<h2 id="building-dockerfile-in-local">Building Dockerfile in local</h2>
<p>Go to your project directory which has a file named Dockerfile first. Then you should build them.</p>
<pre><code class="language-bash">docker build -t &lt;YOUR DOCKER IMAGE NAME&gt; .
</code></pre>
<p>You can run them in your local machine after the build process completed by <code>docker run</code> command like you run a docker image as usual.</p>
<h2 id="building-dockerfile-with-github-actions">Building Dockerfile with Github Actions</h2>
<p>For more details about Github Actions, please refer to <a href="https://github.com/features/actions">documentation of Github Actions for developer</a>.</p>
<p>Each time you pushing to Github will trigger this action to build Docker image by <code>Dockerfile</code> in the root of project and push it to Docker Hub with <code>latest</code> tag. If you push to Github with a specific tag, pushing to Docker Hub will have the same tag as well.</p>
<pre><code class="language-yml">name: Publish Docker
on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@master
      - name: Publish to Registry
        uses: elgohr/Publish-Docker-Github-Action@master
        with:
          name: &lt;YOUR USERNAME&gt;/&lt;YOUR REPO NAME&gt;
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          tag_names: true
</code></pre>
<h1 id="clean-up">Clean-up</h1>
<blockquote>
<p>For more details, you can see this <a href="https://linuxize.com/post/how-to-remove-docker-images-containers-volumes-and-networks/">post</a>.</p>
</blockquote>
<p>Remove all unused objects involving containers, images and networks.</p>
<pre><code class="language-bash">docker system prune
</code></pre>
<p>In additional to remove all objects, you can append <code>--volumes</code> to the command to remove unused volumes.</p>
<pre><code class="language-bash">docker system prune --volumes
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift Usage]]></title>
        <id>https://www.nxw.name/post/swift-usage/</id>
        <link href="https://www.nxw.name/post/swift-usage/">
        </link>
        <updated>2020-01-03T08:48:49.000Z</updated>
        <summary type="html"><![CDATA[<p>This article is for recording the resources which I collected together about how to gracefully use swift, an language released by Apple in 2014. Hopefully this post will help you.</p>
]]></summary>
        <content type="html"><![CDATA[<p>This article is for recording the resources which I collected together about how to gracefully use swift, an language released by Apple in 2014. Hopefully this post will help you.</p>
<!--MORE-->
<h1 id="projects">Projects</h1>
<p>As with other people who are newcomers to swift, I will start with reading source code by authors who are exprienced. The following projects are with my comments to explain what it is doing.</p>
<ul>
<li>Recordings: It is for Swift 5 and iOS 13 and contains serveral examples under different app architectures, you may visit <a href="https://github.com/xavier-niu/recordings">Github</a> to see more details. Credits: <a href="https://objccn.io/">ObjC China</a></li>
</ul>
<h1 id="serialization-encoding-decoding">Serialization: Encoding &amp; Decoding</h1>
<p>Although Apple Development Documentation is a great reference, it is not for the newbies. You may refer to <a href="http://res.niuxuewei.com/encoder_decoder_slides.pdf">this PDF</a> if you want to learn what is it and how it works.</p>
<h1 id="automatic-reference-counting-arc">Automatic Reference Counting (ARC)</h1>
<p>For beginner, it is a tricky thing to deal with reference counting, although it's easier compared to the situation without ARC. As a result, it causes Strong Reference Cycles if mishandled. There are some posts to describe what is ARC and whether you need <code>[weak self]</code> or <code>[unowned self]</code> in a closure entirely and detailedly:</p>
<ul>
<li><a href="https://www.avanderlee.com/swift/weak-self/">Weak self and unowned self explained in Swift</a></li>
<li><a href="https://medium.com/flawless-app-stories/you-dont-always-need-weak-self-a778bec505ef">You don’t (always) need [weak self]</a></li>
</ul>
<h1 id="stackview">StackView</h1>
<p>UIStackView is a useful component for iOS/macOS developor, and it makes your app more flexible, here are some tutorials for those who are not familiar with:</p>
<ul>
<li>Basic knowledge: <a href="https://www.raywenderlich.com/2198310-uistackview-tutorial-for-ios-introducing-stack-views">UIStackView Tutorial for iOS: Introducing Stack Views</a></li>
<li>How to fix left-hand elements and stretch the last elements to fill the width: <a href="https://stackoverflow.com/questions/44681649/stretch-the-last-element-in-uistackview">Stretch the last element in UIStackView</a></li>
</ul>
<h1 id="apps-life-cycle-for-ios13">App's Life Cycle (for iOS13)</h1>
<p>Official documentations</p>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle">Managing Your App's Life Cycle</a></li>
</ul>
<p>Unofficial documentations</p>
<ul>
<li><a href="https://learnappmaking.com/scene-delegate-app-delegate-xcode-11-ios-13/">The Scene Delegate In Xcode 11 And iOS 13</a></li>
</ul>
<h1 id="getter-setter">Getter &amp; Setter</h1>
<ul>
<li><code>private(set)</code> is a way to set a public getting and private setting, but you could build public setter for yourself as well: <a href="https://www.natashatherobot.com/swift-magic-public-getter-private-setter/">Swift Magic: Public Getter, Private Setter</a></li>
</ul>
<h1 id="package-management">Package Management</h1>
<p>Get start</p>
<ul>
<li><a href="https://github.com/Carthage/Carthage">Carthage</a></li>
<li><a href="https://www.raywenderlich.com/416-carthage-tutorial-getting-started">Carthage Tutorial: Getting Started</a></li>
</ul>
<p>Error of embeded framework in Xcode 11</p>
<pre><code>Multiple commands produce 'xxx.framework':
1) Target 'xxx' has copy command from 'xxx.framework' to 'xxx.framework'
2) That command depends on command in Target 'xxx': script phase “Run Script”
</code></pre>
<ul>
<li><a href="https://stackoverflow.com/questions/46800932/carthage-multiple-build-commands-for-output-file-framework?noredirect=1&amp;lq=1">Carthage: Multiple build commands for output file framework</a></li>
<li><a href="https://github.com/Carthage/Carthage/issues/2897">Xcode 11 documentation update</a></li>
</ul>
<h1 id="reactive-programming">Reactive Programming</h1>
<p>RxSwift &amp; RxCocoa</p>
<ul>
<li><a href="https://www.raywenderlich.com/1228891-getting-started-with-rxswift-and-rxcocoa">Getting Started With RxSwift and RxCocoa</a></li>
<li><a href="https://stackoverflow.com/a/40231605">BehaviorSubject vs Observable?</a></li>
<li><a href="https://medium.com/@R00We/different-between-map-and-flatmap-in-rx-e4230355f17f">Different between Map and FlatMap in RX</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Page 365 of 365: 我的2019]]></title>
        <id>https://www.nxw.name/post/page-365-of-365-wo-de-2019/</id>
        <link href="https://www.nxw.name/post/page-365-of-365-wo-de-2019/">
        </link>
        <updated>2020-01-01T15:50:41.000Z</updated>
        <summary type="html"><![CDATA[<p>就在昨天，趁我睡着的时候彻底和2019年道了别，在2020的开头也是时候回顾我的2019年了。对于这一年，算是真正的经历了几件大事，也慢慢开始触及我原来从来没有也未曾感兴趣的领域，甚至开始思考一些人生之类看似虚无缥缈的问题。这似乎就是别人所谓的成长，在我看来无非是对未来不确定因素的恐慌，一切似乎看得清又看不清。</p>
]]></summary>
        <content type="html"><![CDATA[<p>就在昨天，趁我睡着的时候彻底和2019年道了别，在2020的开头也是时候回顾我的2019年了。对于这一年，算是真正的经历了几件大事，也慢慢开始触及我原来从来没有也未曾感兴趣的领域，甚至开始思考一些人生之类看似虚无缥缈的问题。这似乎就是别人所谓的成长，在我看来无非是对未来不确定因素的恐慌，一切似乎看得清又看不清。</p>
<!-- more -->
<h1 id="毕业">毕业</h1>
<p>上学应该会霸占每一位中国青少年极多的少年时光，我也不例外。相比于初中高中，在大学似乎终于有机会放飞自我，做我真正热爱的事情。也从大学之后，真正的感受到了什么是时光如流水，这4年过的太快，快到让人难以置信。</p>
<p>回头想来也算没荒度人生，我担任过学工的站长，说来也奇怪，在我任站长的一点经历了很多的第一次，第一次举办线上考试，在新生入学那几天我们开发的系统为近1万名新生提供服务，第一次组织易班，第一次举办开学典礼发言人遴选，第一次数字化十佳辅导员投票系统，直到最后我们还得到一间宽敞的、崭新的办公室，虽然装修好了之后就换届了，但这也算是学校领导对我们近一年工作的肯定；也以第一作者身份发表过论文，在与导师一封封邮件中反复修改，尽管四处被拒，但在大三行将结束的那个期末传来了好消息；也拿过国家奖学金，是我人生中第一次因为学习而获得如此巨大的奖励。</p>
<p>我尤其庆幸在大学中遇到了那么多优秀的学长学姐、导师、指导教师、同学、舍友，但是也带着很多遗憾我准备离开校园。在大学的最后一年中，我匆匆忙忙的完成了毕业设计，参加了毕业答辩，在无比炎热的夏天拍了毕业照片。直到真正要走的那一天，我看到图书馆上悬挂的“欢送2019届毕业生”的横幅，我才真正意识到明天的我就与大学彻底无关了，从今往后那个24号楼229宿舍会永久停业，那个我待了三年的学六306也将会充满着陌生的新面孔，对于母校终究成了一名过客。</p>
<h1 id="考研">考研</h1>
<p>在我以前看来，考研算得上是世界中最无趣的事情之一。但是当我真正站在人生交叉口上，真正面对未来诸多不确定时，我开始逐渐拥抱考研。2019年的近8个月中我完全为考研做着准备，甚至最后三个月我几乎连小区院子也没出。在准备的过程中，我仍无法认同所谓的应试教育，尤其是最后一个月看到各式各样的教育机构推出的所谓的“冲刺班”、“救命班”，看到那些所谓的教师熟练的讲述如何不看懂原文就能蒙对之类的内容时，更加深了我对应试教育以及购买这些课程的学生的鄙夷，但是这并不妨碍我在准备考研这段时间中我的收获。</p>
<p>首先，我对数学之类的学科有了全新的认识。在此之前，我认为对数学感兴趣的人都是不可理喻之人，着实无法理解在一行行生硬的定理中该如何激发对这门学科的兴趣。令我大为改观的是张宇老师，一位非常优秀的考研数学老师，他将数学史、应用与生硬的定理和谐的融合为一体。其实那些生硬的定律大都源自于一件甚至可能天天在我们身边发生的事，那些数学大家也是从无知逐渐一步步迈向真理，比如牛顿这一辈子可能都没搞明白微积分的真谛。数学其实本身没有那么枯燥，只是从小到大我们一直接受的应试教育完全抹除了它们的乐趣，而只是生硬的做题、背公式、改错题。</p>
<p>其次，我重新深刻的学习了CS的基础：数据结构、计算机组成原理、操作系统和计算机网络。直到学完的那刻才能真正的了解这些基础的重要性。原来的我也不过只是个CURD Boy(aka API Boy)，天天抱着文档调接口，当然我承认这样确实容易做出能用的产品从而获得巨大的成就感，但是我未曾站在机器的立场想过内部的原理。虽然不知道最终的成绩如何，但是无论如何借由考研的机会让我真的知道我的层次，对于我也算是受益良多。所以2020要立几个Flag：重新完整学习C++并读完Redis的源码。</p>
<p>然后就是健身，虽然考研并不是推动我健身的直接力量（胖才是）。原来也断断续续有去健身房，但是在学校毕竟需要做的事情比较多，课程太过分散，因此也就没怎么有坚持下来，反而在准备考研期间，几乎一天的时间都可以由我自由支配。还有就是将要进入第二个本命年的我，已经明显感觉到身体没以前那么抗造，隔三差五的某些地方就要疼你几天，这确实也是迫使我健身的第二大动力。不过经过半年左右的坚持锻炼（考研前3个月就专心复习，没有再去了），与之前对比确实有很明显的改观。因此考研刚结束我也就马不停蹄的动起来，希望明年的这个时候会有新的改变。</p>
<p>再就是我开始关注政治、经济方面的问题了。这主要源于考研的零碎休息时间刷YouTube，看到一个叫“观视频”的频道，里面的“又见”系列真的做的很不错，虽然有个别的“中吹”嫌疑，但是总体上我认为说的还算客观公正。这里面的教授每个人都有独到的观点，所以真的是强烈推荐。</p>
<p>最后考研带给我的改变就是沉心静气。现在是信息化时代，我们获取信息确实非常方便快捷。任何事情有得有失，信息化还带来了“碎片化”、“极端化”等问题。碎片化其实对我影响最大，以前在接触新东西之前我总是喜欢摸着石头过河，需要什么去网上查一查解决方案，当然这在入门期间确实大有益处，但是越往深处走就会发现这种方便快捷带来的是支离破碎、不成体系的知识，远不如沉心静气看下一本书收获来的多。在考研期间我耐着性子看完了好几本书、做完了好几本题之后，我突然发现原来看完一本书远没有想象中的那么痛苦。这也是我在前面flag里说“重新完整学习C++”，也就是下决心把《C++ Primer》这本书从头到尾看一遍。</p>
<p>BTW，考研期间还掌握了一大技能就是调制港式奶茶，毫不夸张的说味道很赞！XD</p>
<h1 id="2020">2020</h1>
<p>这篇文章写于考研成绩公布之前，心中多少还有些忐忑。正如前面所说未来不确定的因素太多，但谁的青春不迷茫呢？就在考研期间我在twitter上follow了一些中国的独立开发者，没错，在看过他们的推特后激起了我强烈的兴趣。我时常在想如果我发布一款属于自己的产品那该有多好。因此刚考完研，我就已经开始构思我的产品啦！希望在2020年能够发布第一版的demo，为成为freelancer迈出第一步。</p>
<h1 id="goodbye-9012">Goodbye, 9012</h1>
<p>最后的最后还想记录一下在9012年我觉得很不错的一些APP：</p>
<ul>
<li>Surge: 一款几乎完美的网络调试工具，开发者是Yachen Liu</li>
<li>Elpass: 2019年12月发布的一款密码管理工具，开发者是Yachen Liu</li>
<li>Spotify: 今年从QQ音乐转移到了Spotify，去掉了那些花里胡哨的社交功能让听音乐变得更纯粹</li>
<li>Telegram: 一款使用体验完美碾压于微信的聊天工具</li>
</ul>
<p>那么9012再见，2020你好。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git Usage]]></title>
        <id>https://www.nxw.name/post/git-usage/</id>
        <link href="https://www.nxw.name/post/git-usage/">
        </link>
        <updated>2019-11-16T02:08:42.000Z</updated>
        <summary type="html"><![CDATA[<p>Git is an awesome tool for version control. I used to some convenient GUI applications to manage git repository, and  ignored how it works and how to do it by command line. So in this article I will record some useful git commands that I used in development.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Git is an awesome tool for version control. I used to some convenient GUI applications to manage git repository, and  ignored how it works and how to do it by command line. So in this article I will record some useful git commands that I used in development.</p>
<!--MORE-->
<h1 id="initialization">Initialization</h1>
<p>Initialize a local git repository</p>
<pre><code class="language-bash">git init
# recommand the way using ssh
git remote add origin ssh@xxxx
</code></pre>
<p>Push to remote repository</p>
<pre><code class="language-bash">git add .
git commit -a
git push origin master
</code></pre>
<p>Pull from remote repository</p>
<pre><code class="language-bash">git pull origin master
</code></pre>
<p>List the available remote repositories</p>
<pre><code class="language-bash">git remote -v
</code></pre>
<h1 id="branch">Branch</h1>
<p>Create</p>
<pre><code class="language-bash"># create a branch named &quot;branch1&quot;
git checkout -b branch1
</code></pre>
<p>Checkout (from local)</p>
<pre><code class="language-bash">git checkout master
</code></pre>
<p>Checkout (from remote to local)</p>
<pre><code class="language-bash">git checkout -b branch1 origin/branch1
</code></pre>
<p>Merge</p>
<pre><code class="language-bash"># assume you are in master branch and want to merge the code from hotfix
git merge hotfix
</code></pre>
<p>Rename</p>
<pre><code class="language-bash"># rename
git branch -m old-name new-name
# Delete the old-name remote branch and push the new-name local branch.
git push origin :old-name new-name
# Reset the upstream branch for the new-name local branch.
git push origin -u new-name
</code></pre>
<p>Delete local Branch</p>
<pre><code class="language-bash">git branch -d branch_name
# force delete
git branch -D branch_name
</code></pre>
<p>Delete remote branch (remote name: origin, remote branch: branch1)</p>
<pre><code class="language-bash">git push origin --delete branch1
</code></pre>
<h1 id="tag">Tag</h1>
<p>Create</p>
<pre><code class="language-bash"># add tag(e.g. v1.0) for current branch
git tag v1.0

# add tag with commit id(e.g. 039bf8b)
git tag v1.0 039bf8b

# add tag with extra message
git tag -a v1.0 -m &quot;version 1.0&quot;
</code></pre>
<p>View</p>
<pre><code class="language-bash"># view local tags
git tag

# view remote tags
git ls-remote --tags
</code></pre>
<p>Share the Tags</p>
<pre><code class="language-bash"># push a specific tag
git push origin v1.0

# push all local tags for one time
git push origin --tags
</code></pre>
<p>Switch</p>
<pre><code class="language-bash">git checkout v1.0
</code></pre>
<p>Delete remote tag(e.g. v1.0)</p>
<pre><code>git push -d origin v1.0
</code></pre>
<h1 id="fix-untracked-files">Fix untracked files</h1>
<p>For example, although you added some files into .gitignore, those are still tracked by git. The solution of the problem shown in below:</p>
<pre><code class="language-bash">git rm -r --cached .
git add .
git commit -m &quot;fixed untracked files&quot;
</code></pre>
<h1 id="how-to-undo-the-most-recent-commits">How to undo the most recent commits</h1>
<p>The more details could be found in <a href="https://stackoverflow.com/questions/927358/how-do-i-undo-the-most-recent-commits-in-git?page=1&amp;tab=votes#tab-top">StackoverFlow</a>.</p>
<pre><code class="language-bash"># your files will not lose, even index not too
# you can simply recommit again
git reset --soft HEAD~
git commit -a -m &quot;recommit&quot;

# reset with &quot;--hard&quot; would switchs the previous state entirely
# that means this not leaves your files and index both
git reset --hear HEAD~
</code></pre>
<h1 id="resolve-a-merge-conflict-using-the-command-line">Resolve a merge conflict using the command line</h1>
<p>The more details could be found in <a href="https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/">Github Documents</a>.</p>
<pre><code class="language-bash">git status
# &gt;&gt;&gt; OUTPUTS OF git status &lt;&lt;&lt;
# On branch master
# You have unmerged paths.
#   (fix conflicts and run &quot;git commit&quot;)
#   (use &quot;git merge --abort&quot; to abort the merge)
#
# Changes to be committed:
#
#         new file:   socket_learning/class3/__init__.py
#         new file:   socket_learning/class3/db/Message.txt
#         new file:   socket_learning/class3/db/User.txt
#         new file:   socket_learning/class3/models/message.py
#         new file:   socket_learning/class3/models/user.py
#
# Unmerged paths:
#   (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution)
#
#         deleted by us:   socket_learning/class3/models/__init__.py
#         added by us:     socket_learning/server_impl/models/__init__.py
#         both modified:   socket_learning/server_impl/routes.py
# 
# Untracked files:
#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
#
#         socket_learning/__pycache__/
#         socket_learning/server_impl/__pycache__/
</code></pre>
<p><code>delete by us</code> and <code>added by us</code> can be added or deleted simply using the following command.</p>
<pre><code class="language-bash">git add &lt;file&gt;
git rm &lt;file&gt;
</code></pre>
<p><code>both modified</code> should manually merge using the text editor, like Vim or Atom. In these case, the conflict of <code>routes.py</code> is showing as below</p>
<pre><code class="language-python">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:socket_learning/server_impl/routes.py
from socket_learning.server_impl.models.message import Message
from socket_learning.server_impl.models.user import User
from socket_learning.server_impl.utils import log
=======
from socket_learning.class3.models.message import Message
from socket_learning.class3.models.user import User
from socket_learning.class3.utils import log
&gt;&gt;&gt;&gt;&gt;&gt;&gt; d8a8b9b8ad0e55b7216520600ae1bf809b5b2aa7:socket_learning/class3/routes.py
</code></pre>
<p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>,<code>=======</code> and<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> indicates the places where conflict occurred, you should determine what the contents is the right one and change it with text editor.</p>
<pre><code class="language-python"># handle the conflicts manually
from socket_learning.server_impl.models.message import Message
from socket_learning.server_impl.models.user import User
from socket_learning.server_impl.utils import log
</code></pre>
<p>Save it and recommit them.</p>
<pre><code class="language-bash">git add .
git commit -a -m &quot;Merge branch 'master' of github.com:xavier-niu/python-playground&quot;
</code></pre>
<h1 id="remove-all-history-commits">Remove all history commits</h1>
<p>Checkout</p>
<pre><code class="language-bash"># the core use for &quot;git checkout --orphan&quot; is to reach 
# a &quot;git init&quot;-like situation on a non-new repository
git checkout --orphan latest_branch
</code></pre>
<p>Add all the files</p>
<pre><code class="language-bash">git add -A
</code></pre>
<p>Commit the changes</p>
<pre><code class="language-bash">git commit -am &quot;commit message&quot;
</code></pre>
<p>Delete the master branch (or what branch you want to clean)</p>
<pre><code class="language-bash">git branch -D master
</code></pre>
<p>Rename the current branch to master</p>
<pre><code class="language-bash">git branch -m master
</code></pre>
<p>Finally, force update your repository</p>
<pre><code class="language-bash">git push -f origin master
</code></pre>
<h1 id="integrate-commit-and-push-into-one-command">Integrate commit and push into one command</h1>
<p>This not supports by the build-in git command. But we can add a customized function into <code>.bash_profile</code>(for mac) to implement it.</p>
<pre><code class="language-bash"># lazygit for using commit and push in one command
# usage: lazygit &quot;commit msg&quot;
function lazygit() {
	git add .
	git commit -am &quot;$1&quot;
	git push
}
</code></pre>
<h1 id="restore-the-deleted-file">Restore the deleted file</h1>
<p>Assume that <code>test.txt</code> is the file you want to restore. First of all, find the last commit that affected the given path.</p>
<pre><code class="language-bash">git rev-list -n 1 HEAD -- test.txt
# outputs: 145107deebdbbad4ce0824b0dbb6f648b5515de7
</code></pre>
<p>The outputs are the id of the last commit. Checkout the version at the commit before, using the caret symbol.</p>
<pre><code class="language-bash">git checkout 145107deebdbbad4ce0824b0dbb6f648b5515de7^ -- text.txt
</code></pre>
<p>Or in one command</p>
<pre><code class="language-bash">git checkout $(get rev-list -n 1 HEAD -- text.txt)^ -- text.txt
</code></pre>
<h1 id="refuse-to-merge-unrelated-histories">Refuse to Merge Unrelated Histories</h1>
<p>Git reports an error when pulling from remote source.</p>
<pre><code>XavierNius-iMac:lucius-dev xavierniu$ git pull origin master
From github.com:xavier-niu/docker-lucius
 * branch            master     -&gt; FETCH_HEAD
fatal: refusing to merge unrelated histories
</code></pre>
<p>The following command with <code>--allow-unrelated-histories</code> is work.</p>
<pre><code class="language-bash">git pull origin master --allow-unrelated-histories
</code></pre>
<h1 id="git-clone-with-specific-port">Git Clone with Specific Port</h1>
<p>The git clone command with default port is</p>
<pre><code class="language-bash">git clone git@localhost:root/lucius.git
</code></pre>
<p>Assume that the port is 1923, the command is switch to</p>
<pre><code class="language-bash">git clone ssh://git@@localhost:1923/root/lucius.git
</code></pre>
<p>What we added:</p>
<ul>
<li>ssh protocol at the beginning of address</li>
<li>the port you specified behind the colon</li>
</ul>
<h1 id="move-files-when-checkout-a-new-branch-without-commit-or-merge">Move Files When Checkout a New Branch without Commit or Merge</h1>
<p>Sometimes, I often forget to checkout a new branch when composing a new module. Therefore, I don't want to commit it, neither want to merge it, but only would like to save current status and change the branch in that I haven't reached the milestone. To achieve it, I recommend to use <code>stash</code> command.</p>
<pre><code class="language-bash"># step 1
git stash
# step 2: checkout
git checkout new-branch
# step 3: restore current status
git stash pop
</code></pre>
<h1 id="use-git-over-a-proxy">Use Git over a Proxy</h1>
<p>Assume that there is a proxy like <code>127.0.0.1:1080</code>, both http and ssh proxy should be configed to ensure we can access the remote resources through any ways, like ssh protocol.</p>
<pre><code class="language-bash"># git http proxy
git config --global http.proxy socks5://127.0.0.1:1080
</code></pre>
<p>Add the following lines into <code>~/.ssh/config</code>, this method is passed on the macOS, other OS I haven't test.</p>
<pre><code>Host github.com
    ProxyCommand          nc -X connect -x 127.0.0.1:1081 %h %p
    ServerAliveInterval   10m
</code></pre>
<p>BTW, in the git http proxy config, you should use socks proxy with the &quot;socks5://&quot; prefix, on the contrary, in the ssh config, you should use http proxy.</p>
<hr>
<h1 id="update-logs">Update Logs</h1>
<p>This post will be updated continuously with my development. There are the logs to better know when I updated those contents:</p>
<ul>
<li>January 20, 2019: <code>init</code> move all contents from Notion to my blog</li>
<li>January 21, 2019: <code>add</code> remove all history commits</li>
<li>January 22, 2019:
<ul>
<li><code>add</code> branch &gt; delete remote branch</li>
<li><code>update</code> tag &gt; create</li>
<li><code>add</code> tag &gt; delete remote tag</li>
<li><code>update</code> tag &gt; share the tags</li>
<li><code>update</code> tag &gt; view</li>
</ul>
</li>
<li>January 27, 2019: <code>add</code> integrate commit and push into one command</li>
<li>February 3, 2019: <code>add</code> restore the deleted file</li>
<li>February 27, 2019: <code>add</code> refuse to merge unrelated histories</li>
<li>March 8, 2019: <code>add</code> git clone with specific port</li>
<li>March 17, 2019: <code>add</code> move files ehen checkout a new branch without commit or merge</li>
<li>April 4, 2019: <code>add</code> use git over a proxy</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Success] Hackintosh on Gigabyte Z370N WiFi with i5-8500]]></title>
        <id>https://www.nxw.name/post/success-hackintosh-on-gigabyte-z370n-wifi-with-i5-8500/</id>
        <link href="https://www.nxw.name/post/success-hackintosh-on-gigabyte-z370n-wifi-with-i5-8500/">
        </link>
        <updated>2019-10-18T15:20:14.000Z</updated>
        <summary type="html"><![CDATA[<p>I'm new to Hackintosh. When installed it on my comp, I almost got stuck at anywhere except post-installation.</p>
]]></summary>
        <content type="html"><![CDATA[<p>I'm new to Hackintosh. When installed it on my comp, I almost got stuck at anywhere except post-installation.</p>
<!--MORE-->
<p>Firstly, if you hang on &quot;Installing Bootloader&quot; with Unibeast 9.0.0, please try to reinstall your macOS, which you use Unibeast, after backup with Time Machine. Besides, I suggest when you want to build yourself at very first time <strong>DO NOT</strong> buy XFX video card, which I took about 1 week to handle an error &quot;attempting system restart&quot;, although it appears at Tony's buyer guide.</p>
<p>Update Log:</p>
<ul>
<li>Oct 15, 2019: support macOS Catalina</li>
<li>Oct 16, 2019: update stuffs related to bluetooth for macOS Catalina</li>
<li>Oct 17, 2019: fix system panic after sleeping after updated to 10.15(19A602)</li>
<li>Oct 30, 2019: update for macOS 10.15.1</li>
<li>Dec 19, 2019: [WARNING] updating to 10.15.2 should be carefully, a process named &quot;com.apple.parsec-fbf.flush&quot; which is running and keeping active in background until power off can lead your Hackintosh can't sleep properly. To get more info and a temporary solution, you may refer to <a href="https://www.tonymacx86.com/threads/process-com-apple-parsec-fbf-flush-on-catalina-10-15-2-prevents-system-from-sleeping-automatically.288951/">this post on tonymacx86</a>.</li>
<li>Jan 1, 2020: replace BCM94352Z with BCM94360CS2, a network card is natively supported by Apple, hence, all info related to wifi and bluetooth is removed.</li>
<li><strong>Aug 9, 2020: This post is deprecated, because I have changed from Clover to OpenCore, which is a better choice for Hackintosh for the moment. So any topics about Clover will not be updated, instead, if you have any problems with OpenCore, I think I may help you to figure out.</strong></li>
</ul>
<h1 id="hardware-summary">Hardware  Summary</h1>
<ul>
<li>MoBo: Gigabyte Z370N WiFi (M-ITX)</li>
<li>CPU: Intel Core i5-8500</li>
<li>Memory: Corsair Vengerance LPX DDR4 16G 3000MHz x2</li>
<li>Graphics Card: Sapphire RX 580 Pulse 8GB</li>
<li>Drives: Samsung EVO850 500G</li>
<li>Wireless Network Card: BCM94360CS2 (NGFF + M.2)</li>
<li>PSUs: CoolerMaster MWE GOLD 650W</li>
<li>CPU Cooler: CoolMaster T400i</li>
<li>Case: Antec Cube - Designed By Razer</li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://res.niuxuewei.com/2018-12-29-IMG_1249.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="http://res.niuxuewei.com/2018-12-29-085816.png" alt="" loading="lazy"></figure>
<h1 id="bios-options">BIOS Options</h1>
<p>As for BIOS options, I fellow with @CaseySJ's guide at <a href="https://www.tonymacx86.com/threads/success-ongoing-status-of-designare-z390-with-i7-9700k.266065/page-29#post-1880116">here</a>. There are huge differences (at least in the name of options) between the motherboards, you should refer to other tutorials if your motherboard not from Gigabyte.</p>
<ul>
<li>M.I.T &gt; Extreme Memory Profile (X.M.P.) &gt; Profile 1 <s>(The problem of usb devices unexpected disconnection after sleeping may take place if opt-in Profile 1, in turn you can have higher memory frequency that  could pass over 2133MHz.)</s></li>
<li>BIOS &gt; Windows 8/10 Features &gt; Windows 8/10 (cuz there is not the option of &quot;Other OS&quot;)</li>
<li>BIOS &gt; CSM Support &gt; Disabled</li>
<li>BIOS &gt; Secure Boot &gt; Disabled</li>
<li>Peripherals &gt; Intel Platform Trust Technology (PTT)  &gt; Disabled</li>
<li>Peripherals &gt; USB Configuration &gt; Legacy USB Support &gt; Enabled</li>
<li>Peripherals &gt; USB Configuration &gt; XHCI Hand-off &gt; Enabled</li>
<li>Peripherals &gt; Network Stack Configuration &gt; Network Stack &gt; Disabled</li>
<li>Chipset &gt; Vt-d &gt; Disabled</li>
<li>Chipset &gt; Internal Graphics &gt; Enabled</li>
<li>Chipset &gt; DVMT Pre-Alloc &gt; 64M</li>
<li>Chipset &gt; DVMT Total Gfx Mem &gt; 256M</li>
<li>Chipset &gt; Above 4G Decoding &gt; Enabled</li>
</ul>
<h1 id="post-installation">Post-Installation</h1>
<p>The method of kext installation and rebuilding kext cache: Copy the kexts you want to install into the folder (like /Library/Extensions, aka /L/E, or other locations). Then, download the <strong>Kext Utility</strong> that help you rebuild the kext cache and others from <a href="http://cvad-mac.narod.ru/index/0-4">here</a>.</p>
<p>I did following thing at the stage of post-installation:</p>
<ul>
<li>
<p>Multibeast: Install clover on the SSD of Hackintosh.</p>
</li>
<li>
<p>Config.plist: I applied this <a href="http://res.niuxuewei.com/config.plist">config</a> provided by @CaseySJ and works fine on my hackintosh.</p>
</li>
<li>
<p>USB 3.0: Download <a href="http://res.niuxuewei.com/SSDT-UIAC-GA-Z370N-WIFI.aml">SSDT</a> and copy it into <code>/EFI/ACPI/patched/</code></p>
</li>
<li>
<p>Kexts installed on my Hackintosh:</p>
<ul>
<li>AppleALC.kext (Audio)</li>
<li>FakeSMC.kext</li>
<li>Lilu.kext</li>
<li>USBInjectAll.kext (USB)</li>
<li>XHCI-unsupported.kext (USB)</li>
<li>WhateverGreen.kext (AMD Graphics Card) <em>(EDIT@Oct 30, 2019: For AMD users, please update WhateverGreen.kext to 1.3.4 or newer to support macOS 10.15.1, otherwise, blackscreen would happen when booting.)</em></li>
<li>IntelMausiEthernet.kext (Ethernet) <em>(EDIT@Oct 17, 2019: the old version may arise system panic after sleeping. To resolve it, you should clone project of the latest from <a href="https://github.com/Mieze/IntelMausiEthernet">this repo</a> and build it by yourself with Xcode, in the end copy &amp; paste it into <code>/L/E</code> folder.)</em></li>
</ul>
</li>
<li>
<p>Enable HiDPI for 2K resolution display: see <a href="https://github.com/xzhih/one-key-hidpi">this repo</a></p>
</li>
<li>
<p>Previews, a built-in app on macOS, cannot previews jpg files by pressing space functionally: As mentioned in Github of NoVPAjpeg, the latest Lilu could fix it with additional boot arguments.</p>
</li>
</ul>
<h1 id="summary">Summary</h1>
<p>What works:</p>
<ul>
<li>audio</li>
<li>graphics card</li>
<li>shutdown / restart / sleep</li>
<li>WiFi</li>
<li>bluetooth</li>
<li>airdrop</li>
<li>handoff</li>
<li>unlock with Apple Watch</li>
</ul>
<p>That's all. Thanks for everyone who helped me build my first Hackintosh at Tonymacx86, especially for @CaseySJ's generous and patient help. I am writing this post for  those who has similar config and installs Hackintosh in their first attempt, hopefully it can help you.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac Terminal使用Shadowsocks连接网络]]></title>
        <id>https://www.nxw.name/post/mac-terminal-shi-yong-shadowsocks-lian-jie-wang-luo/</id>
        <link href="https://www.nxw.name/post/mac-terminal-shi-yong-shadowsocks-lian-jie-wang-luo/">
        </link>
        <updated>2019-10-18T13:27:22.000Z</updated>
        <summary type="html"><![CDATA[<p>最近需要在mac上使用homebrew安装软件，但是homebrew的软件都是在github上的，恰巧这几天校园网一直无法访问github，就从网上查找到了terminal使用代理的方式：</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近需要在mac上使用homebrew安装软件，但是homebrew的软件都是在github上的，恰巧这几天校园网一直无法访问github，就从网上查找到了terminal使用代理的方式：</p>
<!-- MORE -->
<ol>
<li>
<p>在mac上的shadowsocks的设置：</p>
 <img src="http://res.niuxuewei.com/2018-04-29-022952.png" height="300px">
</li>
<li>
<p>开启Terminal输入：</p>
<pre><code class="language-bash"># 一般端口为1080 我的ss的设置是1086
export http_proxy=socks5://127.0.0.1:1086
export https_proxy=socks5://127.0.0.1:1086
# 或者
export ALL_PROXY=socks5://127.0.0.1:1086
</code></pre>
</li>
<li>
<p>Enjoy!XD</p>
</li>
</ol>
<p>[EDIT@Oct 15, 2019] 其实核心在于找到本地代理的端口（地址一般是127.0.0.1），因此在其余的软件，诸如Surge、Clash、ShadowsocksR(SSR)，都是差不多的原理。不过使用Surge的话有更容易的快捷键，点击Surge在菜单栏的图标后按住&quot;Command + C&quot;即可快捷复制上述代码。</p>
<p>需要注意的是</p>
<ul>
<li>
<p>这个只对当前terminal窗口有效</p>
</li>
<li>
<p>ping命令无法作为有效的检查工具，因为ping命令运行于网络层，而代理是在运输层之上的，我们可以用<code>curl</code>命令检测代理是否可用</p>
<pre><code class="language-bash">curl -i https://www.google.com
</code></pre>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://res.niuxuewei.com/2018-04-29-024410.png" alt="对比图" loading="lazy"></figure>
<p>为了更加方便，我们可以通过别名(alias)在~~~/.bashrc~~文件中设置别名来快速开启或关闭代理（注意在macOS Catalina及以上默认Bash改为了ZSH，因此设置文件是<code>~/.zshrc</code>，其余发行版需根据实际情况设置）</p>
<pre><code class="language-bash">vi ~/.bash_profile	# 编辑配置文件
alias setproxy=&quot;export ALL_PROXY=socks5://127.0.0.1:1086&quot;
alias unsetproxy=&quot;unset ALL_PROXY&quot;
:wq保存后
source ~/.bash_profile	# 立即生效
setproxy	# 开启代理
unsetproxy	# 关闭代理 
</code></pre>
<h1 id="references">References</h1>
<ul>
<li><a href="https://www.noxxxx.com/mac-%E4%B8%8B%E7%BB%88%E7%AB%AF%E8%B5%B0-ss-%E4%BB%A3%E7%90%86.html">#1 Mac 下终端走 ss代理</a></li>
<li><a href="http://gaocegege.com/Blog/%E9%9A%8F%E7%AC%94/shadowsocks-with-terminal">#2 如何在OS X 10.11的Terminal中使用shadowsocks</a></li>
<li><a href="https://www.jianshu.com/p/30ffeff2ce53">#3 MAC下终端走代理的几种方法</a></li>
</ul>
]]></content>
    </entry>
</feed>