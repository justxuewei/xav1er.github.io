<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Xavier&#39;s Blog</title>
<meta name="description" content="About code, about life, about everything." />
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico?v=1583923315098">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="http://localhost:4000/styles/main.css">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-129706677-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129706677-2');
</script>


  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="http://localhost:4000">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="http://localhost:4000/images/avatar.png?v=1583923315098" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">Xavier&#39;s Blog</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            Contents
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#reminder-the-general-methodology-to-build-a-nerual-network-is-to">Reminder: The general methodology to build a Nerual Network is to:</a></li>
<li><a href="#a-single-hidden-layer-neural-network-source-code">A Single Hidden Layer Neural Network Source Code</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          Home
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          Archives
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          Tags
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          About
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by Gridea & GitHub.</div>
    <a class="rss" href="http://localhost:4000/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">DEEPLEARNING.AI NOTES FOR LESSON1_WEEK3 QUIZ</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2017-10-21 / 7 min read
        </div>
        
        <div class="post-content yue">
          <h3 id="reminder-the-general-methodology-to-build-a-nerual-network-is-to">Reminder: The general methodology to build a Nerual Network is to:</h3>
<ol>
<li>Define the neural network structure (# of input units, # of hidden units, etc.).</li>
<li>Initialize the model's parameters</li>
<li>Loop:
<ul>
<li>Implement forward propagation</li>
<li>Compute loss</li>
<li>Implement backward propagation to get the gradients</li>
<li>Update parameters(gradient descent)</li>
</ul>
</li>
</ol>
<p>You often build helper functions to compute steps 1-3 and then merge them into one function wa call nn_model().</p>
<!--MORE-->
<h3 id="a-single-hidden-layer-neural-network-source-code">A Single Hidden Layer Neural Network Source Code</h3>
<p><strong>Environment</strong></p>
<ul>
<li>Language: Python 3+</li>
<li>Extra Library: Anaconda</li>
<li>IDE: PyCharm 2017.2</li>
<li>OS: Mac OS 10.13</li>
<li>Reference: Deeplearning.ai Courses at (study.163.com)</li>
<li>Notes: There are some very small error(less than 0.0001) when we are running compute_cost function, and receive three warnings from console. (I have marked in source code.) The reason of that is caused by predicted value that appoach to zero closely, so the solution of that is using not standard normal distribution when initialze the weights in your code.</li>
</ul>
<p><strong>Directory Structure</strong></p>
<pre><code>deeplearning_ai_week3
|- Main.py
|- planar_utils.py
|- testCases.py
</code></pre>
<p><a href="http://7xqjkf.com1.z0.glb.clouddn.com/planar_utils.py" title="planar_utils.py donwload link">planar_utils.py donwload link</a><br>
<a href="http://7xqjkf.com1.z0.glb.clouddn.com/planar_utils.py" title="testCases.py download link">testCases.py download link</a></p>
<p><strong>Source Code</strong></p>
<pre><code class="language-python"># Main.py source code

import numpy as np
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
from deeplearning_ai_week3.testCases import *
import sklearn
import sklearn.datasets
import sklearn.linear_model
from deeplearning_ai_week3.planar_utils import plot_decision_boundary, sigmoid, load_extra_datasets, load_planar_dataset


def layer_sizes(X, Y):
    n_x = X.shape[0]  # size of input layer
    n_h = 4
    n_y = Y.shape[0]  # size of output layer

    return n_x, n_h, n_y


# Initialize the model's parameters
def initialize_parameters(n_x, n_h, n_y):
    np.random.seed(2)

    W1 = np.random.randn(n_h, n_x) * 0.01
    b1 = np.zeros((n_h, 1))
    W2 = np.random.randn(n_y, n_h) * 0.01
    b2 = np.zeros((n_y, 1))

    assert (W1.shape == (n_h, n_x))
    assert (b1.shape == (n_h, 1))
    assert (W2.shape == (n_y, n_h))
    assert (b2.shape == (n_y, 1))

    parameters = {&quot;W1&quot;: W1,
                  &quot;b1&quot;: b1,
                  &quot;W2&quot;: W2,
                  &quot;b2&quot;: b2}

    return parameters


def compute_cost(A2, Y, parameters):
    m = Y.shape[1]

    &quot;&quot;&quot;
    There are errors below:
    1. RuntimeWarning: divide by zero encountered in log 
    logprobs = np.multiply(Y, np.log(A2)) + np.multiply((1. - Y), np.log(1. - A2))
    2. RuntimeWarning: overflow encountered in exp
    s = 1/(1+np.exp(-x))
    &quot;&quot;&quot;
    logprobs = np.multiply(np.log(A2), Y) + np.multiply((1 - Y), np.log(1 - A2))
    cost = - np.sum(logprobs) / m

    cost = np.squeeze(cost)

    assert isinstance(cost, float)

    return cost


def forward_propagation(X, parameters):
    W1 = parameters[&quot;W1&quot;]
    b1 = parameters[&quot;b1&quot;]
    W2 = parameters[&quot;W2&quot;]
    b2 = parameters[&quot;b2&quot;]

    Z1 = np.dot(W1, X) + b1
    A1 = np.tanh(Z1)
    Z2 = np.dot(W2, A1) + b2
    A2 = sigmoid(Z2)

    assert (A2.shape == (1, X.shape[1]))

    cache = {&quot;Z1&quot;: Z1,
             &quot;A1&quot;: A1,
             &quot;Z2&quot;: Z2,
             &quot;A2&quot;: A2}

    return A2, cache


def backward_propagation(parameters, cache, X, Y):
    m = X.shape[1]

    W1 = parameters[&quot;W1&quot;]
    W2 = parameters[&quot;W2&quot;]

    A1 = cache[&quot;A1&quot;]
    A2 = cache[&quot;A2&quot;]

    '''
    Why calculating dZx don't need to divided by m and dWx, dbx need?
    '''
    dZ2 = A2 - Y
    dW2 = (1 / m) * np.dot(dZ2, A1.T)
    db2 = (1 / m) * np.sum(dZ2, axis=1, keepdims=True)
    '''
    I don't know why use np.multiply(np.dot(W2.T, dZ2), (1 - np.power(A1, 2))) instead of np.dot()
    What is the different between them?

    The shapes of each element are:
    W2.T.shape == (4, 1)
    dZ2.shape == (1, 400)
    np.dot(W2.T, dZ2).shape == (4, 400)
    A1.shape = (4, 400)
    '''
    dZ1 = np.dot(W2.T, dZ2) * (1 - np.power(A1, 2))
    dW1 = (1 / m) * np.dot(dZ1, X.T)
    db1 = (1 / m) * np.sum(dZ1, axis=1, keepdims=True)

    grads = {&quot;dW1&quot;: dW1,
             &quot;db1&quot;: db1,
             &quot;dW2&quot;: dW2,
             &quot;db2&quot;: db2}

    return grads


def update_parameters(parameters, grads, learning_rate=1.2):
    W1 = parameters[&quot;W1&quot;]
    b1 = parameters[&quot;b1&quot;]
    W2 = parameters[&quot;W2&quot;]
    b2 = parameters[&quot;b2&quot;]

    dW1 = grads[&quot;dW1&quot;]
    db1 = grads[&quot;db1&quot;]
    dW2 = grads[&quot;dW2&quot;]
    db2 = grads[&quot;db2&quot;]

    W1 -= learning_rate * dW1
    b1 -= learning_rate * db1
    W2 -= learning_rate * dW2
    b2 -= learning_rate * db2

    parameters = {&quot;W1&quot;: W1,
                  &quot;b1&quot;: b1,
                  &quot;W2&quot;: W2,
                  &quot;b2&quot;: b2}

    return parameters


def nn_model(X, Y, n_h, num_iterations=10000, print_cost=False):
    np.random.seed(3)
    n_x = layer_sizes(X, Y)[0]
    n_y = layer_sizes(X, Y)[2]

    parameters = initialize_parameters(n_x, n_h, n_y)
    W1 = parameters[&quot;W1&quot;]
    b1 = parameters[&quot;b1&quot;]
    W2 = parameters[&quot;W2&quot;]
    b2 = parameters[&quot;b2&quot;]

    for i in range(0, num_iterations):
        A2, cache = forward_propagation(X, parameters)
        cost = compute_cost(A2, Y, parameters)
        grads = backward_propagation(parameters, cache, X, Y)
        parameters = update_parameters(parameters, grads)

        if print_cost and i % 1000 == 0:
            print(&quot;Cost after iteration %i: %f&quot; % (i, cost))

    return parameters


def predict(parameters, X):
    A2, cache = forward_propagation(X, parameters)
    predictions = np.round(A2)

    return predictions


if __name__ == '__main__':
    np.random.seed(1)

    # Load a &quot;flower&quot; 2-class data set into variable X and Y
    X, Y = load_planar_dataset()

    # Build a model with a n_h-dimensional hidden layer
    parameters = nn_model(X, Y, n_h=4, num_iterations=10000, print_cost=True)

    predictions = predict(parameters, X)
    print('Accuracy: %d' % float(
        (np.dot(Y, predictions.T) + np.dot(1 - Y, 1 - predictions.T)) / float(Y.size) * 100) + '%')

    # Plot the decision boundary
    plot_decision_boundary(lambda x: predict(parameters, x.T), X, Y)
    plt.title(&quot;Decision Boundary for hidden layer size &quot; + str(4))
    plt.show()
</code></pre>
<p><strong>Result</strong></p>
<pre><code>Cost after iteration 0: 0.693048
Cost after iteration 1000: 0.288083
Cost after iteration 2000: 0.254385
Cost after iteration 3000: 0.233864
Cost after iteration 4000: 0.226792
Cost after iteration 5000: 0.222644
Cost after iteration 6000: 0.219731
Cost after iteration 7000: 0.217504
Cost after iteration 8000: 0.219506
Cost after iteration 9000: 0.218621
Accuracy: 90%
</code></pre>
<figure data-type="image" tabindex="1"><a href="http://7xqjkf.com1.z0.glb.clouddn.com/LESSON1_WEEK3_RESULT_FIGURE.png" title="ResultFigure"><img src="http://7xqjkf.com1.z0.glb.clouddn.com/LESSON1_WEEK3_RESULT_FIGURE.png" alt="ResultFigure" title="ResultFigure" loading="lazy"></a></figure>

        </div>

        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="http://localhost:4000/post/deeplearning-ai-notes-for-lesson1-week4-quiz/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  DEEPLEARNING.AI NOTES FOR LESSON1_WEEK4 QUIZ
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="http://localhost:4000/post/logistic-regression/">
                <h3 class="post-title">
                  Logistic Regression
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://geektutu.github.io/hexo-theme-geektutu/js/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '95da5e6dfbe94e9621c5',
    clientSecret: '6b6510006d4bd9b042323bc2c5b1374561942033',
    repo: 'xav1er.github.io',
    owner: 'xavier-niu',
    admin: ['xavier-niu'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false,  // Facebook-like distraction free mode
    language: 'en'
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="http://localhost:4000/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
