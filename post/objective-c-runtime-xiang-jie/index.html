<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Xavier&#39;s Blog</title>
<meta name="description" content="About code, about life, about everything." />
<link rel="shortcut icon" href="https://www.nxw.name/favicon.ico?v=1584067803267">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://www.nxw.name/styles/main.css">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-129706677-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129706677-2');
</script>


  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://www.nxw.name">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://www.nxw.name/images/avatar.png?v=1584067803267" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">Xavier&#39;s Blog</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            Contents
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">类与对象基础数据结构</a>
<ul>
<li><a href="#objc_class">objc_class</a></li>
<li><a href="#objc_object%E4%B8%8Eid">objc_object与id</a></li>
<li><a href="#objc_cache">objc_cache</a></li>
<li><a href="#%E5%85%83%E7%B1%BBmeta-class">元类(meta class)</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">类与对象操作函数</a>
<ul>
<li><a href="#%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">类相关操作函数</a>
<ul>
<li><a href="#%E7%B1%BB%E5%90%8Dname">类名(name)</a></li>
<li><a href="#%E7%88%B6%E7%B1%BBsuper_class%E5%92%8C%E5%85%83%E7%B1%BBmeta-class">父类(super_class)和元类(meta-class)</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%A4%A7%E5%B0%8Finstance_size">实例变量大小(instance_size)</a></li>
<li><a href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8Fivars%E5%8F%8A%E5%B1%9E%E6%80%A7">成员变量(ivars)及属性</a></li>
<li><a href="#%E6%96%B9%E6%B3%95methodlists">方法(methodLists)</a></li>
<li><a href="#%E5%8D%8F%E8%AE%AEobjc_protocol_list">协议(objc_protocol_list)</a></li>
<li><a href="#%E7%89%88%E6%9C%ACversion">版本(version)</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8Bexample">实例(Example)</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">动态创建类和对象</a>
<ul>
<li><a href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%B1%BB">动态创建类</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">动态创建对象</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">实例操作函数</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AE%9A%E4%B9%89">获取类定义</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A0%81type-encoding">类型编码(Type Encoding)</a></li>
<li><a href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%B1%9E%E6%80%A7">成员变量、属性</a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基础数据类型</a>
<ul>
<li><a href="#ivar">Ivar</a></li>
<li><a href="#objc_property_t">objc_property_t</a></li>
<li><a href="#objc_property_attribute_t">objc_property_attribute_t</a></li>
</ul>
</li>
<li><a href="#%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1associated-object">关联对象(Associated Object)</a></li>
<li><a href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95">成员变量、属性的操作方法</a>
<ul>
<li><a href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">成员变量</a></li>
<li><a href="#%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1">关联对象</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7">属性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E4%BE%8B">实例</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2">基础数据类型</a>
<ul>
<li><a href="#sel">SEL</a></li>
<li><a href="#imp">IMP</a></li>
<li><a href="#method">Method</a>
<ul>
<li><a href="#objc_method_description">objc_method_description</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">方法相关操作函数</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E9%80%89%E6%8B%A9%E5%99%A8">方法选择器</a></li>
</ul>
</li>
<li><a href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B">方法调用流程</a>
<ul>
<li><a href="#%E9%9A%90%E8%97%8F%E5%8F%82%E6%95%B0">隐藏参数</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%9C%B0%E5%9D%80">获取方法地址</a></li>
</ul>
</li>
<li><a href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91">消息转发</a>
<ul>
<li><a href="#%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90">动态方法解析</a></li>
<li><a href="#%E5%A4%87%E7%94%A8%E6%8E%A5%E6%94%B6%E8%80%85">备用接收者</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91">完整消息转发</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B8%8E%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF">消息转发与多重继承</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          Home
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          Archives
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          Tags
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          About
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by Gridea & GitHub.</div>
    <a class="rss" href="https://www.nxw.name/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">Objective-C Runtime详解</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-03-06 / 65 min read
        </div>
        
        <div class="post-content yue">
          <blockquote>
<p>最近在学习RxSwift，对于DelegateProxy如何进行消息转发问题比较感兴趣，所以仔细阅读了源码，发现其在底层利用了Objective-C Runtime的特性实现消息转发，因此在网上找到了这一系列的文章。<br>
这篇文章大部分内容转自<a href="http://southpeak.github.io/categories/objectivec/">南峰子的技术博客</a>。由于年代久远的关系，其部分图片已经404，遂在这篇文章中进行补齐，同时对于文中描述的一些不是很清楚的内容加入了我的理解。<br>
实际上该系列文章下分六篇独立文章，在我的版本中将单独的文章予以合并以图后续查阅方便。</p>
</blockquote>
<!-- more -->
<p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时能够更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。</p>
<p>这种特性意味着Objective-C不仅需要一个编译器，还需要一个<mark>运行时系统</mark>来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即Objc Runtime。Objc Runtime其实是一个Runtime库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>
<p>Runtime库主要做下面几件事：</p>
<p>封装：在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</p>
<p>找出方法的最终执行代码：当程序执行[object doSomething]时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者是否能响应该消息而做出不同的反应。这将在后面详细介绍。</p>
<p>Objective-C runtime目前有两个版本：Modern runtime和Legacy runtime。Modern Runtime 覆盖了64位的Mac OS X Apps，还有 iOS Apps，Legacy Runtime 是早期用来给32位 Mac OS X Apps 用的，也就是可以不用管就是了。</p>
<p>在这一系列文章中，我们将介绍runtime的基本工作原理，以及如何利用它让我们的程序变得更加灵活。在本文中，我们先来介绍一下类与对象，这是面向对象的基础，我们看看在Runtime中，类是如何实现的。</p>
<h1 id="类与对象基础数据结构">类与对象基础数据结构</h1>
<h2 id="objc_class">objc_class</h2>
<p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：</p>
<pre><code class="language-c">typedef struct objc_class *Class;
</code></pre>
<p>查看objc/runtime.h中objc_class结构体的定义如下：</p>
<pre><code class="language-c">struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class super_class                       OBJC2_UNAVAILABLE;  // 父类
    const char *name                        OBJC2_UNAVAILABLE;  // 类名
    long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0
    long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识
    long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小
    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表
    struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表
    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存
    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表
#endif

} OBJC2_UNAVAILABLE;
</code></pre>
<p>在这个定义中，下面几个字段是我们感兴趣的：</p>
<ul>
<li>isa：需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的Class里面也有一个isa指针，它指向metaClass(元类)，我们会在后面介绍它。</li>
<li>super_class：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则super_class为NULL。</li>
<li>cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。</li>
<li>version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</li>
</ul>
<p>针对cache，我们用下面例子来说明其执行过程：</p>
<pre><code class="language-objc">NSArray *array = [[NSArray alloc] init];
</code></pre>
<p>其流程是：</p>
<ul>
<li>[NSArray alloc]先被执行。因为NSArray没有+alloc方法，于是去父类NSObject去查找。</li>
<li>检测NSObject是否响应+alloc方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把<mark>isa指针指向NSArray类</mark>。同时，+alloc也被加进cache列表里面。</li>
<li>接着，执行-init方法，如果NSArray响应该方法，则直接将其加入cache；如果不响应，则去父类查找。</li>
</ul>
<p>在后期的操作中，如果再以[[NSArray alloc] init]这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。</p>
<h2 id="objc_object与id">objc_object与id</h2>
<p>objc_object是表示一个类的实例的结构体，它的定义如下(objc/objc.h)：</p>
<pre><code class="language-c">struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};

typedef struct objc_object *id;
</code></pre>
<p>可以看到，这个结构体只有一个成员，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。</p>
<p>当创建一个特定类的实例对象时，分配的内存包含一个objc_object数据结构，然后是类的实例变量的数据。NSObject类的alloc和allocWithZone:方法使用函数class_createInstance来创建objc_object数据结构。</p>
<p>另外还有我们常见的id，它是一个objc_object结构类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中void *指针类型的作用。</p>
<h2 id="objc_cache">objc_cache</h2>
<p>上面提到了objc_class结构体中的cache字段，它用于缓存调用过的方法。这个字段是一个指向objc_cache结构体的指针，其定义如下：</p>
<pre><code class="language-c">struct objc_cache {
    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;
    unsigned int occupied                                    OBJC2_UNAVAILABLE;
    Method buckets[1]                                        OBJC2_UNAVAILABLE;
};
</code></pre>
<p>该结构体的字段描述如下：</p>
<ul>
<li>mask：一个整数，指定分配的缓存bucket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法。</li>
<li>occupied：一个整数，指定实际占用的缓存bucket的总数。</li>
<li>buckets：指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。</li>
</ul>
<h2 id="元类meta-class">元类(meta class)</h2>
<p>在上面我们提到，<mark>所有的类自身也是一个对象</mark>，我们可以向这个对象发送消息(即调用类方法)。如：</p>
<pre><code class="language-objc">NSArray *array = [NSArray array];
</code></pre>
<p>这个例子中，+array消息发送给了NSArray类，而这个NSArray也是一个对象。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么这些就有一个问题了，这个isa指针指向什么呢？为了调用+array方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念：</p>
<p>meta-class是一个类对象的类。</p>
<p><mark>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</mark></p>
<p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p>
<p>再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。这样就形成了一个完美的闭环。</p>
<p>通过上面的描述，再加上对objc_class结构体中super_class指针的分析，我们就可以描绘出类及相应meta-class类的一个继承体系了，如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="http://res.niuxuewei.com/2020-03-05-072215.png" alt="Screen-Shot-2016-03-04-at-12-14-44-AM-1" loading="lazy"></figure>
<p>对于NSObject继承体系来说，其实例方法对体系中的所有实例、类和meta-class都是有效的；而类方法对于体系内的所有类和meta-class都是有效的。</p>
<p>讲了这么多，我们还是来写个例子吧：</p>
<pre><code class="language-objc">void TestMetaClass(id self, SEL _cmd) {

    NSLog(@&quot;This objcet is %p&quot;, self);
    NSLog(@&quot;Class is %@, super class is %@&quot;, [self class], [self superclass]);

    Class currentClass = [self class];
    for (int i = 0; i &lt; 4; i++) {
        NSLog(@&quot;Following the isa pointer %d times gives %p&quot;, i, currentClass);
        currentClass = objc_getClass((__bridge void *)currentClass);
    }

    NSLog(@&quot;NSObject's class is %p&quot;, [NSObject class]);
    NSLog(@&quot;NSObject's meta class is %p&quot;, objc_getClass((__bridge void *)[NSObject class]));
}

#pragma mark -

@implementation Test

- (void)ex_registerClassPair {

    Class newClass = objc_allocateClassPair([NSError class], &quot;TestClass&quot;, 0);
    class_addMethod(newClass, @selector(testMetaClass), (IMP)TestMetaClass, &quot;v@:&quot;);
    objc_registerClassPair(newClass);

    id instance = [[newClass alloc] initWithDomain:@&quot;some domain&quot; code:0 userInfo:nil];
    [instance performSelector:@selector(testMetaClass)];
}

@end
</code></pre>
<p>这个例子是在运行时创建了一个<code>NSError</code>的子类<code>TestClass</code>，然后为这个子类添加一个方法<code>testMetaClass</code>，这个方法的实现是<code>TestMetaClass</code>函数。</p>
<p>运行后，打印结果是</p>
<pre><code>2014-10-20 22:57:07.352 mountain[1303:41490] This objcet is 0x7a6e22b0
2014-10-20 22:57:07.353 mountain[1303:41490] Class is TestStringClass, super class is NSError
2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 0 times gives 0x7a6e21b0
2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 1 times gives 0x0
2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 2 times gives 0x0
2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 3 times gives 0x0
2014-10-20 22:57:07.353 mountain[1303:41490] NSObject's class is 0xe10000
2014-10-20 22:57:07.354 mountain[1303:41490] NSObject's meta class is 0x0
</code></pre>
<p>我们在for循环中，我们通过<code>objc_getClass</code>来获取对象的<code>isa</code>，并将其打印出来，依此一直回溯到NSObject的<code>meta-class</code>。分析打印结果，可以看到最后指针指向的地址是0x0，即NSObject的<code>meta-class</code>的类地址。</p>
<p><em>这里需要注意的是：我们在一个类对象调用class方法是无法获取meta-class，它只是返回类而已。</em></p>
<h1 id="类与对象操作函数">类与对象操作函数</h1>
<p>runtime提供了大量的函数来操作类与对象。类的操作方法大部分是以<code>class_</code>为前缀的，而对象的操作方法大部分是以<code>objc_</code>或<code>object_</code>为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。</p>
<h2 id="类相关操作函数">类相关操作函数</h2>
<p>我们可以回过头去看看<code>objc_class</code>的定义，runtime提供的操作类的方法主要就是针对这个结构体中的各个字段的。下面我们分别介绍这一些的函数。并在最后以实例来演示这些函数的具体用法。</p>
<h3 id="类名name">类名(name)</h3>
<p>类名操作的函数主要有：</p>
<pre><code class="language-c">// 获取类的类名
const char * class_getName ( Class cls );
</code></pre>
<p>说明：</p>
<ul>
<li>对于<code>class_getName</code>函数，如果传入的<code>cls</code>为<code>Nil</code>，则返回一个字符串。</li>
</ul>
<h3 id="父类super_class和元类meta-class">父类(super_class)和元类(meta-class)</h3>
<p>父类和元类操作的函数主要有：</p>
<pre><code class="language-c">// 获取类的父类
Class class_getSuperclass ( Class cls );
// 判断给定的Class是否是一个元类
BOOL class_isMetaClass ( Class cls );
</code></pre>
<p>说明：</p>
<ul>
<li><code>class_getSuperclass</code>函数，当<code>cls</code>为Nil或者<code>cls</code>为根类时，返回Nil。不过通常我们可以使用NSObject类的<code>superclass</code>方法来达到同样的目的。</li>
<li><code>class_isMetaClass</code>函数，如果是<code>cls</code>是元类，则返回YES；如果否或者传入的<code>cls</code>为Nil，则返回NO。</li>
</ul>
<h3 id="实例变量大小instance_size">实例变量大小(instance_size)</h3>
<p>实例变量大小操作的函数有：</p>
<pre><code class="language-c">// 获取实例大小
size_t class_getInstanceSize ( Class cls );
</code></pre>
<h3 id="成员变量ivars及属性">成员变量(ivars)及属性</h3>
<p>在<code>objc_class</code>中，所有的成员变量、属性的信息是放在链表<code>ivars</code>中的。<code>ivars</code>是一个数组，数组中每个元素是指向<code>Ivar</code>(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：</p>
<blockquote>
<p>Marked by Xavier：</p>
<ul>
<li>
<p>有关成员变量、属性的相关内容请参见：https://www.jianshu.com/p/55f781f8c915</p>
</li>
<li>
<p>Ivar实际上是一个指向objc_ivar的指针，其具体定义为</p>
<pre><code class="language-c">typedef struct objc_ivar *Ivar;

struct objc_ivar
{
   char *ivar_name;
   char *ivar_type;
   int ivar_offset;
};
</code></pre>
<p>参见：http://mirror.informatimago.com/next/developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/9objc_runtime_reference/chapter_5_section_56.html</p>
</li>
</ul>
</blockquote>
<ol>
<li>
<p>成员变量操作函数，主要包含以下函数：</p>
<pre><code class="language-c">// 获取类中指定名称实例成员变量的信息
Ivar class_getInstanceVariable ( Class cls, const char *name );
// 获取类成员变量的信息
Ivar class_getClassVariable ( Class cls, const char *name );
// 添加成员变量
BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );
// 获取整个成员变量列表
Ivar * class_copyIvarList ( Class cls, unsigned int *outCount );
</code></pre>
<p>说明：</p>
<ul>
<li><code>class_getInstanceVariable</code>函数，它返回一个指向包含name指定的成员变量信息的<code>objc_ivar</code>结构体的指针(<code>Ivar</code>)。</li>
<li><code>class_getClassVariable</code>函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。</li>
<li>Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用<code>class_addIvar</code>函数了。不过需要注意的是，这个方法只能在<code>objc_allocateClassPair</code>函数与<code>objc_registerClassPair</code>之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是<code>1&lt;&lt;alignment</code>。这取决于<code>ivar</code>的类型和机器的架构。如果变量的类型是指针类型，则传递<code>log2(sizeof(pointer_type))</code>。</li>
<li><code>class_copyIvarList</code>函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的<code>objc_ivar</code>结构体的指针。这个数组不包含在父类中声明的变量。<code>outCount</code>指针返回数组的大小。需要注意的是，我们必须使用<code>free()</code>来释放这个数组。</li>
</ul>
</li>
<li>
<p>属性操作函数，主要包含以下函数：</p>
<pre><code class="language-c">// 获取指定的属性
objc_property_t class_getProperty ( Class cls, const char *name );
// 获取属性列表
objc_property_t * class_copyPropertyList ( Class cls, unsigned int *outCount );
// 为类添加属性
BOOL class_addProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );
// 替换类的属性
void class_replaceProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );
</code></pre>
<p>这一种方法也是针对<code>ivars</code>来操作，不过只操作那些是属性的值。我们在后面介绍属性时会再遇到这些函数。</p>
</li>
<li>
<p>在MAC OS X系统中，我们可以使用垃圾回收器。runtime提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理<code>strong/weak</code>引用。这几个函数定义如下：</p>
<pre><code class="language-c">const uint8_t * class_getIvarLayout ( Class cls );
void class_setIvarLayout ( Class cls, const uint8_t *layout );
const uint8_t * class_getWeakIvarLayout ( Class cls );
void class_setWeakIvarLayout ( Class cls, const uint8_t *layout );
</code></pre>
<p>但通常情况下，我们不需要去主动调用这些方法；在调用<code>objc_registerClassPair</code>时，会生成合理的布局。在此不详细介绍这些函数。</p>
</li>
</ol>
<h3 id="方法methodlists">方法(methodLists)</h3>
<p>方法操作主要有以下函数：</p>
<pre><code class="language-c">// 添加方法
BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );
// 获取实例方法
Method class_getInstanceMethod ( Class cls, SEL name );
// 获取类方法
Method class_getClassMethod ( Class cls, SEL name );
// 获取所有方法的数组
Method * class_copyMethodList ( Class cls, unsigned int *outCount );
// 替代方法的实现
IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );
// 返回方法的具体实现
IMP class_getMethodImplementation ( Class cls, SEL name );
IMP class_getMethodImplementation_stret ( Class cls, SEL name );
// 类实例是否响应指定的selector
BOOL class_respondsToSelector ( Class cls, SEL sel );
</code></pre>
<p>说明：</p>
<ul>
<li>
<p><code>class_addMethod</code>的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。如果要修改已存在实现，可以使用<code>method_setImplementation</code>。一个Objective-C方法是一个简单的C函数，它至少包含两个参数–<code>self</code>和<code>_cmd</code>。所以，我们的实现函数(IMP参数指向的函数)至少需要两个参数，如下所示：</p>
<pre><code class="language-c">void myMethodIMP(id self, SEL _cmd)
{
    // implementation ....
}
</code></pre>
<p>与成员变量不同的是，我们可以为类动态添加方法，不管这个类是否已存在。另外，参数<code>types</code>是一个描述传递给方法的参数类型的字符数组，这就涉及到类型编码，我们将在后面介绍。</p>
</li>
<li>
<p><code>class_getInstanceMethod</code>、<code>class_getClassMethod</code>函数，与<code>class_copyMethodList</code>不同的是，这两个函数都会去搜索父类的实现。</p>
</li>
<li>
<p><code>class_copyMethodList</code>函数，返回包含所有<mark>实例方法</mark>的数组，如果需要获取类方法，则可以使用<code>class_copyMethodList(object_getClass(cls), &amp;count)</code>(一个类的实例方法是定义在元类里面)。该列表不包含父类实现的方法。<code>outCount</code>参数返回方法的个数。在获取到列表后，我们需要使用<code>free()</code>方法来释放它。</p>
</li>
<li>
<p><code>class_replaceMethod</code>函数，该函数的行为可以分为两种：如果类中不存在name指定的方法，则类似于<code>class_addMethod</code>函数一样会添加方法；如果类中已存在name指定的方法，则类似于<code>method_setImplementation</code>一样替代原方法的实现。</p>
</li>
<li>
<p><code>class_getMethodImplementation</code>函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比<code>method_getImplementation(class_getInstanceMethod(cls, name))</code>更快。返回的函数指针可能是一个指向runtime内部的函数，而不一定是方法的实际实现。例如，如果类实例无法响应<code>selector</code>，则返回的函数指针将是运行时消息转发机制的一部分。</p>
</li>
<li>
<p><code>class_respondsToSelector</code>函数，我们通常使用NSObject类的<code>respondsToSelector:</code>或<code>instancesRespondToSelector:</code>方法来达到相同目的。</p>
</li>
</ul>
<h3 id="协议objc_protocol_list">协议(objc_protocol_list)</h3>
<p>协议相关的操作包含以下函数：</p>
<pre><code class="language-c">// 添加协议
BOOL class_addProtocol ( Class cls, Protocol *protocol );
// 返回类是否实现指定的协议
BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );
// 返回类实现的协议列表
Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount );
</code></pre>
<p>说明：</p>
<ul>
<li><code>class_conformsToProtocol</code>函数可以使用NSObject类的<code>conformsToProtocol:</code>方法来替代。</li>
<li><code>class_copyProtocolList</code>函数返回的是一个数组，在使用后我们需要使用<code>free()</code>手动释放。</li>
</ul>
<h3 id="版本version">版本(version)</h3>
<p>版本相关的操作包含以下函数：</p>
<pre><code class="language-c">// 获取版本号
int class_getVersion ( Class cls );
// 设置版本号
void class_setVersion ( Class cls, int version );
</code></pre>
<h3 id="其他">其他</h3>
<p>runtime还提供了两个函数来供<code>CoreFoundation</code>的<code>tool-free bridging</code>使用，即：</p>
<pre><code class="language-c">Class objc_getFutureClass ( const char *name );
void objc_setFutureClass ( Class cls, const char *name );
</code></pre>
<p>通常我们不直接使用这两个函数。</p>
<h3 id="实例example">实例(Example)</h3>
<p>上面列举了大量类操作的函数，下面我们写个实例，来看看这些函数的实例效果：</p>
<pre><code class="language-objc">//-----------------------------------------------------------
// MyClass.h
@interface MyClass : NSObject &lt;NSCopying, NSCoding&gt;
@property (nonatomic, strong) NSArray *array;
@property (nonatomic, copy) NSString *string;
- (void)method1;
- (void)method2;
+ (void)classMethod1;
@end
//-----------------------------------------------------------
// MyClass.m
#import &quot;MyClass.h&quot;
@interface MyClass () {
    NSInteger       _instance1;
    NSString    *   _instance2;
}
@property (nonatomic, assign) NSUInteger integer;
- (void)method3WithArg1:(NSInteger)arg1 arg2:(NSString *)arg2;
@end
@implementation MyClass
+ (void)classMethod1 {
}
- (void)method1 {
    NSLog(@&quot;call method method1&quot;);
}
- (void)method2 {
}
- (void)method3WithArg1:(NSInteger)arg1 arg2:(NSString *)arg2 {
    NSLog(@&quot;arg1 : %ld, arg2 : %@&quot;, arg1, arg2);
}
@end
//-----------------------------------------------------------
// main.h
#import &quot;MyClass.h&quot;
#import &quot;MySubClass.h&quot;
#import &lt;objc/runtime.h&gt;
int main(int argc, const char * argv[]) {
    @autoreleasepool {
    
        MyClass *myClass = [[MyClass alloc] init];
        unsigned int outCount = 0;
        Class cls = myClass.class;
        // 类名
        NSLog(@&quot;class name: %s&quot;, class_getName(cls));
        NSLog(@&quot;==========================================================&quot;);
        // 父类
        NSLog(@&quot;super class name: %s&quot;, class_getName(class_getSuperclass(cls)));
        NSLog(@&quot;==========================================================&quot;);
        // 是否是元类
        NSLog(@&quot;MyClass is %@ a meta-class&quot;, (class_isMetaClass(cls) ? @&quot;&quot; : @&quot;not&quot;));
        NSLog(@&quot;==========================================================&quot;);
      	// 上一个例子中使用objc_getClass()获取isa以获得meta class
        Class meta_class = objc_getMetaClass(class_getName(cls));
        NSLog(@&quot;%s's meta-class is %s&quot;, class_getName(cls), class_getName(meta_class));
        NSLog(@&quot;==========================================================&quot;);
        // 变量实例大小
        NSLog(@&quot;instance size: %zu&quot;, class_getInstanceSize(cls));
        NSLog(@&quot;==========================================================&quot;);
        // 成员变量
        Ivar *ivars = class_copyIvarList(cls, &amp;outCount);
        for (int i = 0; i &lt; outCount; i++) {
            Ivar ivar = ivars[i];
            NSLog(@&quot;instance variable's name: %s at index: %d&quot;, ivar_getName(ivar), i);
        }
        free(ivars);
        Ivar string = class_getInstanceVariable(cls, &quot;_string&quot;);
        if (string != NULL) {
            NSLog(@&quot;instace variable %s&quot;, ivar_getName(string));
        }
        NSLog(@&quot;==========================================================&quot;);
        // 属性操作
        objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);
        for (int i = 0; i &lt; outCount; i++) {
            objc_property_t property = properties[i];
            NSLog(@&quot;property's name: %s&quot;, property_getName(property));
        }
        free(properties);
        objc_property_t array = class_getProperty(cls, &quot;array&quot;);
        if (array != NULL) {
            NSLog(@&quot;property %s&quot;, property_getName(array));
        }
        NSLog(@&quot;==========================================================&quot;);
        // 方法操作
        Method *methods = class_copyMethodList(cls, &amp;outCount);
        for (int i = 0; i &lt; outCount; i++) {
            Method method = methods[i];
            NSLog(@&quot;method's signature: %s&quot;, method_getName(method));
        }
        free(methods);
        Method method1 = class_getInstanceMethod(cls, @selector(method1));
        if (method1 != NULL) {
            NSLog(@&quot;method %s&quot;, method_getName(method1));
        }
        Method classMethod = class_getClassMethod(cls, @selector(classMethod1));
        if (classMethod != NULL) {
            NSLog(@&quot;class method : %s&quot;, method_getName(classMethod));
        }
        NSLog(@&quot;MyClass is%@ responsd to selector: method3WithArg1:arg2:&quot;, class_respondsToSelector(cls, @selector(method3WithArg1:arg2:)) ? @&quot;&quot; : @&quot; not&quot;);
        IMP imp = class_getMethodImplementation(cls, @selector(method1));
        imp();
        NSLog(@&quot;==========================================================&quot;);
        // 协议
        Protocol * __unsafe_unretained * protocols = class_copyProtocolList(cls, &amp;outCount);
        Protocol * protocol;
        for (int i = 0; i &lt; outCount; i++) {
            protocol = protocols[i];
            NSLog(@&quot;protocol name: %s&quot;, protocol_getName(protocol));
        }
        NSLog(@&quot;MyClass is%@ responsed to protocol %s&quot;, class_conformsToProtocol(cls, protocol) ? @&quot;&quot; : @&quot; not&quot;, protocol_getName(protocol));
        NSLog(@&quot;==========================================================&quot;);
    }
    return 0;
}
</code></pre>
<p>这段程序的输出如下：</p>
<pre><code>2014-10-22 19:41:37.452 RuntimeTest[3189:156810] class name: MyClass
2014-10-22 19:41:37.453 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] super class name: NSObject
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass is not a meta-class
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass's meta-class is MyClass
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance size: 48
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _instance1 at index: 0
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _instance2 at index: 1
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _array at index: 2
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _string at index: 3
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instance variable's name: _integer at index: 4
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instace variable _string
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property's name: array
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property's name: string
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property's name: integer
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property array
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method1
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method2
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method3WithArg1:arg2:
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: integer
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setInteger:
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: array
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: string
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setString:
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setArray:
2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method's signature: .cxx_destruct
2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method method1
2014-10-22 19:41:37.466 RuntimeTest[3189:156810] class method : classMethod1
2014-10-22 19:41:37.466 RuntimeTest[3189:156810] MyClass is responsd to selector: method3WithArg1:arg2:
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] call method method1
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCopying
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCoding
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] MyClass is responsed to protocol NSCoding
2014-10-22 19:41:37.468 RuntimeTest[3189:156810] ==========================================================
</code></pre>
<h2 id="动态创建类和对象">动态创建类和对象</h2>
<p>runtime的强大之处在于它能在运行时创建类和对象。</p>
<h3 id="动态创建类">动态创建类</h3>
<p>动态创建类涉及到以下几个函数：</p>
<pre><code class="language-c">// 创建一个新类和元类
Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes );
// 销毁一个类及其相关联的类
void objc_disposeClassPair ( Class cls );
// 在应用中注册由objc_allocateClassPair创建的类
void objc_registerClassPair ( Class cls );
</code></pre>
<p>说明：</p>
<ul>
<li>
<p><code>objc_allocateClassPair</code>函数：如果我们要创建一个根类，则<code>superclass</code>指定为Nil。<code>extraBytes</code>通常指定为0，该参数是分配给类和元类对象尾部的索引<code>ivars</code>的字节数。</p>
<p>为了创建一个新类，我们需要调用<code>objc_allocateClassPair</code>。然后使用诸如<code>class_addMethod</code>，<code>class_addIvar</code>等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用<code>objc_registerClassPair</code>函数来注册类，之后这个新类就可以在程序中使用了。</p>
<p>实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</p>
</li>
<li>
<p><code>objc_disposeClassPair</code>函数用于销毁一个类，不过需要注意的是，如果程序运行中还存在类或其子类的实例，则不能调用针对类调用该方法。</p>
</li>
</ul>
<p>在前面介绍元类时，我们已经有接触到这几个函数了，在此我们再举个实例来看看这几个函数的使用。</p>
<pre><code class="language-objc">Class cls = objc_allocateClassPair(MyClass.class, &quot;MySubClass&quot;, 0);

// imp_submethod1是一个已实现的C语言方法，用于规定新建的submethod1和method1的行为
class_addMethod(cls, @selector(submethod1), (IMP)imp_submethod1, &quot;v@:&quot;);
class_replaceMethod(cls, @selector(method1), (IMP)imp_submethod1, &quot;v@:&quot;);
class_addIvar(cls, &quot;_ivar1&quot;, sizeof(NSString *), log(sizeof(NSString *)), &quot;i&quot;);

objc_property_attribute_t type = {&quot;T&quot;, &quot;@\&quot;NSString\&quot;&quot;};
objc_property_attribute_t ownership = { &quot;C&quot;, &quot;&quot; };
objc_property_attribute_t backingivar = { &quot;V&quot;, &quot;_ivar1&quot;};
objc_property_attribute_t attrs[] = {type, ownership, backingivar};

class_addProperty(cls, &quot;property2&quot;, attrs, 3);
objc_registerClassPair(cls);

id instance = [[cls alloc] init];
[instance performSelector:@selector(submethod1)];
[instance performSelector:@selector(method1)];
</code></pre>
<p>程序的输出如下：</p>
<pre><code>2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1
2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1
</code></pre>
<h3 id="动态创建对象">动态创建对象</h3>
<p>动态创建对象的函数如下：</p>
<pre><code class="language-c">// 创建类实例
id class_createInstance ( Class cls, size_t extraBytes );
// 在指定位置创建类实例
id objc_constructInstance ( Class cls, void *bytes );
// 销毁类实例
void * objc_destructInstance ( id obj );
</code></pre>
<p>说明：</p>
<ul>
<li>
<p><code>class_createInstance</code>函数：创建实例时，会在默认的内存区域为实例分配内存。<code>extraBytes</code>参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。<br>
调用<code>class_createInstance</code>的效果与<code>+alloc</code>方法类似。不过在使用<code>class_createInstance</code>时，我们需要确切的知道我们要用它来做什么。在下面的例子中，我们用NSString来测试一下该函数的实际效果：</p>
<pre><code class="language-objc">id theObject = class_createInstance(NSString.class, sizeof(unsigned));
 
id str1 = [theObject init];
NSLog(@&quot;%@&quot;, [str1 class]);
id str2 = [[NSString alloc] initWithString:@&quot;test&quot;];
NSLog(@&quot;%@&quot;, [str2 class]);
</code></pre>
<p>输出结果是：</p>
<pre><code>2014-10-23 12:46:50.781 RuntimeTest[4039:89088] NSString
2014-10-23 12:46:50.781 RuntimeTest[4039:89088] __NSCFConstantString
</code></pre>
<p>可以看到，使用<code>class_createInstance</code>函数获取的是NSString实例，而不是类簇中的默认占位符类<code>__NSCFConstantString</code>。</p>
</li>
<li>
<p><code>objc_constructInstance</code>函数：在指定的位置(bytes)创建类实例。</p>
</li>
<li>
<p><code>objc_destructInstance</code>函数：销毁一个类的实例，但不会释放并移除任何与其相关的引用。</p>
</li>
</ul>
<h3 id="实例操作函数">实例操作函数</h3>
<p>实例操作函数主要是针对我们创建的实例对象的一系列操作函数，我们可以使用这组函数来从实例对象中获取我们想要的一些信息，如实例对象中变量的值。这组函数可以分为三小类：</p>
<ol>
<li>
<p>针对整个对象进行操作的函数，这类函数包含</p>
<pre><code class="language-c">// 返回指定对象的一份拷贝
id object_copy ( id obj, size_t size );
// 释放指定对象占用的内存
id object_dispose ( id obj );
</code></pre>
<p>有这样一种场景，假设我们有类A和类B，且类B是类A的子类。类B通过添加一些额外的属性来扩展类A。现在我们创建了一个A类的实例对象，并希望在运行时将这个对象转换为B类的实例对象，这样可以添加数据到B类的属性中。这种情况下，我们没有办法直接转换，因为B类的实例会比A类的实例更大，没有足够的空间来放置对象。此时，我们就要以使用以上几个函数来处理这种情况，如下代码所示：</p>
<pre><code class="language-objc">// 在这个例子中类A是NSObject，类B是MyClass
// 创建NSObject类的子类
NSObject *a = [[NSObject alloc] init];
// 拷贝a到newB并且实例大小与MyClass相同
id newB = object_copy(a, class_getInstanceSize(MyClass.class));
// 赋予newB的类为MyClass
object_setClass(newB, MyClass.class);
// 释放a
object_dispose(a);
</code></pre>
</li>
<li>
<p>针对对象实例变量进行操作的函数，这类函数包含：</p>
<pre><code class="language-c">// 修改类实例的实例变量的值
Ivar object_setInstanceVariable ( id obj, const char *name, void *value );
// 获取对象实例变量的值
Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );
// 返回指向给定对象分配的任何额外字节的指针
void * object_getIndexedIvars ( id obj );
// 返回对象中实例变量的值
id object_getIvar ( id obj, Ivar ivar );
// 设置对象中实例变量的值
void object_setIvar ( id obj, Ivar ivar, id value );
</code></pre>
<p>如果实例变量的<code>Ivar</code>已经知道，那么调用<code>object_getIvar</code>会比<code>object_getInstanceVariable</code>函数快，相同情况下，<code>object_setIvar</code>也比<code>object_setInstanceVariable</code>快。</p>
</li>
<li>
<p>针对对象的类进行操作的函数，这类函数包含：</p>
<pre><code class="language-c">// 返回给定对象的类名
const char * object_getClassName ( id obj );
// 返回对象的类
Class object_getClass ( id obj );
// 设置对象的类
Class object_setClass ( id obj, Class cls );
</code></pre>
</li>
</ol>
<h3 id="获取类定义">获取类定义</h3>
<p>Objective-C动态运行库会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用<code>objc_addClass</code>函数来注册它们。<code>runtime</code>提供了一系列函数来获取类定义相关的信息，这些函数主要包括：</p>
<pre><code class="language-c">// 获取已注册的类定义的列表
int objc_getClassList ( Class *buffer, int bufferCount );
// 创建并返回一个指向所有已注册类的指针列表
Class* objc_copyClassList ( unsigned int *outCount );
// 返回指定类的类定义
Class objc_lookUpClass ( const char *name );
Class objc_getClass ( const char *name );
Class objc_getRequiredClass ( const char *name );
// 返回指定类的元类
Class objc_getMetaClass ( const char *name );
</code></pre>
<p>说明：</p>
<ul>
<li><code>objc_getClassList</code>函数：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现。</li>
</ul>
<blockquote>
<p>“我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现。” —— 为什么调用上面的方法需要检测在类中是否实现？</p>
</blockquote>
<p>下面代码演示了该函数的用法：</p>
<pre><code class="language-objc">int numClasses;
Class * classes = NULL;
// 首先检测已注册的类的数量是否大于0
numClasses = objc_getClassList(NULL, 0);
if (numClasses &gt; 0) {
    classes = malloc(sizeof(Class) * numClasses);
    numClasses = objc_getClassList(classes, numClasses);
    NSLog(@&quot;number of classes: %d&quot;, numClasses);
    for (int i = 0; i &lt; numClasses; i++) {
        Class cls = classes[i];
        NSLog(@&quot;class name: %s&quot;, class_getName(cls));
  }
    free(classes);
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>2014-10-23 16:20:52.589 RuntimeTest[8437:188589] number of classes: 1282
2014-10-23 16:20:52.589 RuntimeTest[8437:188589] class name: DDTokenRegexp
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: _NSMostCommonKoreanCharsKeySet
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: OS_xpc_dictionary
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: NSFileCoordinator
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: NSAssertionHandler
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: PFUbiquityTransactionLogMigrator
2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: NSNotification
2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: NSKeyValueNilSetEnumerator
2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: OS_tcp_connection_tls_session
2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: _PFRoutines
......还有大量输出
</code></pre>
<ul>
<li>
<p>获取类定义的方法有三个：<code>objc_lookUpClass</code>, <code>objc_getClass</code>和<code>objc_getRequiredClass</code>。如果类在运行时未注册，则<code>objc_lookUpClass</code>会返回nil，而<code>objc_getClass</code>会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。而<code>objc_getRequiredClass</code>函数的操作与<code>objc_getClass</code>相同，只不过如果没有找到类，则会杀死进程。</p>
</li>
<li>
<p><code>objc_getMetaClass</code>函数：如果指定的类没有注册，则该函数会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义，不管它是否有效。</p>
</li>
</ul>
<p>在前面一篇文章中，我们介绍了Runtime中与类和对象相关的内容，从这章开始，我们将讨论类实现细节相关的内容，主要包括类中成员变量，属性，方法，协议与分类的实现。</p>
<p>本章的主要内容将聚集在Runtime对成员变量与属性的处理。在讨论之前，我们先介绍一个重要的概念：类型编码。</p>
<h1 id="类型编码type-encoding">类型编码(Type Encoding)</h1>
<p>作为对Runtime的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的<code>selector</code>关联在一起。这种编码方案在其它情况下也是非常有用的，因此我们可以使用<code>@encode</code>编译器指令来获取它。当给定一个类型时，<code>@encode</code>返回这个类型的字符串编码。这些类型可以是诸如<code>int</code>、指针这样的基本类型，也可以是结构体、类等类型。事实上，任何可以作为<code>sizeof()</code>操作参数的类型都可以用于<code>@encode()</code>。</p>
<p>在<code>Objective-C Runtime Programming Guide</code>中的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding</a>一节中，列出了Objective-C中所有的类型编码。需要注意的是这些类型很多是与我们用于存档和分发的编码类型是相同的。但有一些不能在存档时使用。</p>
<p><em>注：Objective-C不支持long double类型。@encode(long double)返回d，与double是一样的。</em></p>
<p>一个数组的类型编码位于方括号中；其中包含数组元素的个数及元素类型。如以下示例：</p>
<pre><code class="language-objc">float a[] = {1.0, 2.0, 3.0};
NSLog(@&quot;array encoding type: %s&quot;, @encode(typeof(a)));
</code></pre>
<p>输出是：</p>
<pre><code>2014-10-28 11:44:54.731 RuntimeTest[942:50791] array encoding type: [3f]
</code></pre>
<p>其它类型可参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding</a>，在此不细说。</p>
<p>另外，还有些编码类型，<code>@encode</code>虽然不会直接返回它们，但它们可以作为协议中声明的方法的类型限定符。可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding</a>。</p>
<p>对于属性而言，还会有一些特殊的类型编码，以表明属性是只读、拷贝、<code>retain</code>等等，详情可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6">Property Type String</a>。</p>
<h1 id="成员变量-属性">成员变量、属性</h1>
<p>Runtime中关于成员变量和属性的相关数据结构并不多，只有三个，并且都很简单。不过还有个非常实用但可能经常被忽视的特性，即关联对象，我们将在这小节中详细讨论。</p>
<h2 id="基础数据类型">基础数据类型</h2>
<h3 id="ivar">Ivar</h3>
<p><code>Ivar</code>是表示实例变量的类型，其实际是一个指向<code>objc_ivar</code>结构体的指针，其定义如下：</p>
<pre><code class="language-c">typedef struct objc_ivar *Ivar;
struct objc_ivar {
    char *ivar_name               OBJC2_UNAVAILABLE;	// 变量名
    char *ivar_type             	OBJC2_UNAVAILABLE;	// 变量类型
    int ivar_offset            		OBJC2_UNAVAILABLE;	// 基地址偏移字节
#ifdef __LP64__
    int space                 		OBJC2_UNAVAILABLE;
#endif
}
</code></pre>
<h3 id="objc_property_t">objc_property_t</h3>
<p><code>objc_property_t</code>是表示Objective-C声明的属性的类型，其实际是指向<code>objc_property</code>结构体的指针，其定义如下：</p>
<pre><code class="language-c">typedef struct objc_property *objc_property_t;
</code></pre>
<h3 id="objc_property_attribute_t">objc_property_attribute_t</h3>
<p><code>objc_property_attribute_t</code>定义了属性的特性(<code>attribute</code>)，它是一个结构体，定义如下：</p>
<pre><code class="language-c">typedef struct {
    const char *name;           // 特性名
    const char *value;          // 特性值
} objc_property_attribute_t;
</code></pre>
<h2 id="关联对象associated-object">关联对象(Associated Object)</h2>
<p>关联对象是Runtime中一个非常实用的特性，不过可能很容易被忽视。</p>
<p>关联对象类似于成员变量，不过是在运行时添加的。我们通常会把成员变量(<code>Ivar</code>)放在类声明的头文件中，或者放在类实现的<code>@implementation</code>后面。但这有一个缺点，<mark>我们不能在分类中添加成员变量。如果我们尝试在分类中添加新的成员变量</mark>，编译器会报错。</p>
<p>我们可能希望通过使用(甚至是滥用)全局变量来解决这个问题。但这些都不是<code>Ivar</code>，因为他们不会连接到一个单独的实例。因此，这种方法很少使用。</p>
<p>Objective-C针对这一问题，提供了一个解决方案：即关联对象(<code>Associated Object</code>)。</p>
<p>我们可以把关联对象想象成一个Objective-C对象(如字典)，这个对象通过给定的key连接到类的一个实例上。不过由于使用的是C接口，所以key是一个<code>void</code>指针(<code>const void *</code>)。我们还需要指定一个内存管理策略，以告诉<code>Runtime</code>如何管理这个对象的内存。这个内存管理的策略可以由以下值指定：</p>
<pre><code>OBJC_ASSOCIATION_ASSIGN
OBJC_ASSOCIATION_RETAIN_NONATOMIC
OBJC_ASSOCIATION_COPY_NONATOMIC
OBJC_ASSOCIATION_RETAIN
OBJC_ASSOCIATION_COPY
</code></pre>
<p>当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象。如果指定的策略是<code>assign</code>，则宿主释放时，关联对象不会被释放；而如果指定的是<code>retain</code>或者是<code>copy</code>，则宿主释放时，关联对象会被释放。我们甚至可以选择是否是自动<code>retain/copy</code>。当我们需要在多个线程中处理访问关联对象的多线程代码时，这就非常有用了。</p>
<p>我们将一个对象连接到其它对象所需要做的就是下面两行代码：</p>
<pre><code class="language-c">static char myKey;
objc_setAssociatedObject(self, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);
</code></pre>
<p>在这种情况下，<code>self</code>对象将获取一个新的关联的对象<code>anObject</code>，且内存管理策略是自动<code>retain</code>关联对象，当<code>self</code>对象释放时，会自动<code>release</code>关联对象。另外，如果我们使用同一个key来关联另外一个对象时，也会自动释放之前关联的对象，这种情况下，先前的关联对象会被妥善地处理掉，并且新的对象会使用它的内存。</p>
<pre><code class="language-c">id anObject = objc_getAssociatedObject(self, &amp;myKey);
</code></pre>
<p>我们可以使用<code>objc_removeAssociatedObjects</code>函数来移除一个关联对象，或者使用<code>objc_setAssociatedObject</code>函数将key指定的关联对象设置为nil。</p>
<p>我们下面来用实例演示一下关联对象的使用方法。</p>
<p>假定我们想要动态地将一个Tap手势操作连接到任何<code>UIView</code>中，并且根据需要指定点击后的实际操作。这时候我们就可以将一个手势对象及操作的block对象关联到我们的<code>UIView</code>对象中。这项任务分两部分。首先，如果需要，我们要创建一个手势识别对象并将它及block做为关联对象。如下代码所示：</p>
<pre><code class="language-objc">- (void)setTapActionWithBlock:(void (^)(void))block
{
	UITapGestureRecognizer *gesture = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey);
 
	if (!gesture)
	{
		gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(__handleActionForTapGesture:)];
		[self addGestureRecognizer:gesture];
		objc_setAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);
	}
	objc_setAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);
}
</code></pre>
<p>这段代码检测了手势识别的关联对象。如果没有，则创建并建立关联关系。同时，将传入的块对象连接到指定的key上。注意<code>block</code>对象的关联内存管理策略。<br>
手势识别对象需要一个<code>target</code>和<code>action</code>，所以接下来我们定义处理方法：</p>
<pre><code class="language-objc">- (void)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture
{
	if (gesture.state == UIGestureRecognizerStateRecognized)
	{
		void(^action)(void) = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey);
		if (action)
		{
			action();
		}
	}
}
</code></pre>
<p>我们需要检测手势识别对象的状态，因为我们只需要在点击手势被识别出来时才执行操作。</p>
<p>从上面的例子我们可以看到，关联对象使用起来并不复杂。它让我们可以动态地增强类现有的功能。我们可以在实际编码中灵活地运用这一特性。</p>
<h2 id="成员变量-属性的操作方法">成员变量、属性的操作方法</h2>
<p>在Objective-C 1.0中需要同时声明属性和成员变量：</p>
<pre><code class="language-objc">@interface MyViewController :UIViewController {
    UIButton *myButton; // 成员变量
}
@property (nonatomic, retain) UIButton *myButton; // 属性
@end
</code></pre>
<p>在Objective-C 2.0中，<code>@property</code>它将自动创建一个以下划线开头的成员变量。因此，在这个版本中，我们不再为interface声明实例变量:</p>
<pre><code class="language-objc">@interface MyViewController :UIViewController
@property (nonatomic, retain) UIButton *myButton;
@end
</code></pre>
<h3 id="成员变量">成员变量</h3>
<p>成员变量操作包含以下函数：</p>
<pre><code class="language-c">// 获取成员变量名
const char * ivar_getName ( Ivar v );
// 获取成员变量类型编码
const char * ivar_getTypeEncoding ( Ivar v );
// 获取成员变量的偏移量
ptrdiff_t ivar_getOffset ( Ivar v );
</code></pre>
<p>说明：</p>
<ul>
<li><code>ivar_getOffset</code>函数，对于类型<code>id</code>或其它对象类型的实例变量，可以调用<code>object_getIvar</code>和<code>object_setIvar</code>来直接访问成员变量，而不使用偏移量。</li>
</ul>
<h3 id="关联对象">关联对象</h3>
<p>关联对象操作函数包括以下：</p>
<pre><code class="language-objc">// 设置关联对象
void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );
// 获取关联对象
id objc_getAssociatedObject ( id object, const void *key );
// 移除关联对象
void objc_removeAssociatedObjects ( id object );
</code></pre>
<p>关联对象及相关实例已经在前面讨论过了，在此不再重复。</p>
<h3 id="属性">属性</h3>
<p>属性操作相关函数包括以下：</p>
<pre><code class="language-c">// 获取属性名
const char * property_getName ( objc_property_t property );
// 获取属性特性描述字符串
const char * property_getAttributes ( objc_property_t property );
// 获取属性中指定的特性
char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );
// 获取属性的特性列表
objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount );
</code></pre>
<p>说明：</p>
<ul>
<li><code>property_copyAttributeValue</code>函数，返回的<code>char *</code>在使用完后需要调用<code>free()</code>释放。</li>
<li><code>property_copyAttributeList</code>函数，返回值在使用完后需要调用<code>free()</code>释放。</li>
</ul>
<h1 id="实例">实例</h1>
<p>假定这样一个场景，我们从服务端两个不同的接口获取相同的字典数据，但这两个接口是由两个人写的，相同的信息使用了不同的字段表示。我们在接收到数据时，可将这些数据保存在相同的对象中。对象类如下定义：</p>
<pre><code class="language-objc">// MyObject.h
#import &lt;Foundation/Foundation.h&gt;

NS_ASSUME_NONNULL_BEGIN

@interface MyObject : NSObject

@property (nonatomic, copy) NSString *name;
@property (nonatomic, copy) NSString *status;

- (NSString *)propertyForKey: (NSString *)key;
- (void)setDataWithDic:(NSDictionary *)dic;

@end

NS_ASSUME_NONNULL_END
</code></pre>
<p>接口A、B返回的字典数据如下所示：</p>
<pre><code class="language-objc">@{@&quot;name1&quot;: @&quot;张三&quot;, @&quot;status1&quot;: @&quot;start&quot;}
@{@&quot;name2&quot;: @&quot;张三&quot;, @&quot;status2&quot;: @&quot;end&quot;}
</code></pre>
<p>通常的方法是写两个方法分别做转换，不过如果能灵活地运用Runtime的话，可以只实现一个转换方法，为此，我们需要先定义一个映射字典(全局变量)</p>
<pre><code class="language-objc">// MyObject.m
#import &quot;MyObject.h&quot;
#import &lt;objc/runtime.h&gt;

static NSMutableDictionary *map = nil;

@implementation MyObject

+ (void)load {
    map = [NSMutableDictionary dictionary];
    map[@&quot;name1&quot;] = @&quot;name&quot;;
    map[@&quot;status1&quot;] = @&quot;status&quot;;
    map[@&quot;name2&quot;] = @&quot;name&quot;;
    map[@&quot;status2&quot;] = @&quot;status&quot;;
}

- (NSString *)propertyForKey:(NSString *)key {
    if (map == nil) {
        [MyObject load];
    }
    return map[key];
}

// 上面的代码将两个字典中不同的字段映射到MyObject中相同的属性上，这样，转换方法可如下处理
- (void)setDataWithDic:(NSDictionary *)dic {
    [dic enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) {
        NSString *propertyKey = [self propertyForKey: key];
        NSLog(@&quot;propertyKey: %@&quot;, propertyKey);
        
        if (propertyKey) {
            objc_property_t property = class_getProperty([self class], [propertyKey UTF8String]);
            NSString *attributeString = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];
            NSLog(@&quot;attributeString: %@&quot;, attributeString);
            // ...
            [self setValue:obj forKey:propertyKey];
        }
    }];
}

@end
</code></pre>
<p>当然，一个属性能否通过上面这种方式来处理的前提是其支持KVC。Main函数：</p>
<pre><code class="language-objc">// main.m
#import &lt;Foundation/Foundation.h&gt;
#import &quot;MyObject.h&quot;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        MyObject *myObject = [[MyObject alloc] init];
        [myObject setDataWithDic:@{@&quot;name1&quot;: @&quot;张三&quot;, @&quot;status1&quot;: @&quot;start&quot;}];
        // load data from myObject
        NSLog(@&quot;myObject name: %@, status: %@&quot;, myObject.name, myObject.status);
    }
    return 0;
}
</code></pre>
<p>输出结果</p>
<pre><code>2020-03-04 17:22:11.173 ObjectiveCRuntime[7550:133211] propertyKey: name
2020-03-04 17:22:11.173 ObjectiveCRuntime[7550:133211] attributeString: T@&quot;NSString&quot;,C,N,V_name
2020-03-04 17:22:11.173 ObjectiveCRuntime[7550:133211] propertyKey: status
2020-03-04 17:22:11.173 ObjectiveCRuntime[7550:133211] attributeString: T@&quot;NSString&quot;,C,N,V_status
2020-03-04 17:22:11.173 ObjectiveCRuntime[7550:133211] myObject name: 张三, status: start
</code></pre>
<p>前面我们讨论了Runtime中对类和对象的处理，及对成员变量与属性的处理。这一章，我们就要开始讨论Runtime中最有意思的一部分：消息处理机制。我们将详细讨论消息的发送及消息的转发。不过在讨论消息之前，我们先来了解一下与方法相关的一些内容。</p>
<h1 id="基础数据类型-2">基础数据类型</h1>
<h2 id="sel">SEL</h2>
<p>SEL又叫选择器，是表示一个方法的<code>selector</code>的指针，其定义如下：</p>
<pre><code class="language-c">typedef struct objc_selector *SEL;
</code></pre>
<p><code>objc_selector</code>结构体的详细定义没有在<code>&lt;objc/runtime.h&gt;</code>头文件中找到。方法的<code>selector</code>用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(<code>Int</code>类型的地址)，这个标识就是<code>SEL</code>。如下代码所示：</p>
<pre><code class="language-objc">SEL sel1 = @selector(method1);
NSLog(@&quot;sel : %p&quot;, sel1);
</code></pre>
<p>上面的输出为：</p>
<pre><code>	2014-10-30 18:40:07.518 RuntimeTest[52734:466626] sel : 0x100002d72
</code></pre>
<p>两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的SEL就是一样的。每一个方法都对应着一个<code>SEL</code>。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个<code>SEL</code>。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法的能力很差。如在某个类中定义以下两个方法：</p>
<pre><code class="language-objc">- (void)setWidth:(int)width;
- (void)setWidth:(double)width;
</code></pre>
<p>这样的定义被认为是一种编译错误，所以我们不能像C++, C#那样。而是需要像下面这样来声明：</p>
<pre><code class="language-objc">-(void)setWidthIntValue:(int)width;
-(void)setWidthDoubleValue:(double)width;
</code></pre>
<p>当然，不同的类可以拥有相同的<code>selector</code>，这个没有问题。不同类的实例对象执行相同的<code>selector</code>时，会在各自的方法列表中去根据<code>selector</code>去寻找自己对应的<code>IMP</code>。</p>
<p>工程中的所有的<code>SEL</code>组成一个<code>Set</code>集合，Set的特点就是唯一，因此SEL是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名<code>hash</code>化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！！但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是<code>perfect hash</code>）。但是不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个<code>SEL</code>），那将是最犀利的方法。那么，我们就不难理解，为什么<code>SEL</code>仅仅是函数名了。</p>
<p>本质上，<code>SEL</code>只是一个指向方法的指针（准确的说，只是一个根据方法名<code>hash</code>化了的<code>KEY</code>值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。</p>
<p>我们可以在运行时添加新的<code>selector</code>，也可以在运行时获取已存在的<code>selector</code>，我们可以通过下面三种方法来获取SEL:</p>
<ul>
<li><code>sel_registerName</code>函数</li>
<li>Objective-C编译器提供的<code>@selector()</code></li>
<li><code>NSSelectorFromString()</code>方法</li>
</ul>
<h2 id="imp">IMP</h2>
<p><code>IMP</code>实际上是一个函数指针，指向方法实现的首地址。其定义如下：</p>
<pre><code class="language-c">id (*IMP)(id, SEL, ...)
</code></pre>
<p>这个函数使用当前<code>CPU</code>架构实现的标准的C调用约定。<mark>第一个参数是指向<code>self</code>的指针</mark>(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，<mark>第二个参数是方法选择器(<code>selector</code>)，接下来是方法的实际参数列表。</mark></p>
<p>前面介绍过的<code>SEL</code>就是为了查找方法的最终实现<code>IMP</code>的。由于每个方法对应唯一的<code>SEL</code>，因此我们可以通过<code>SEL</code>方便快速准确地获得它所对应的<code>IMP</code>，查找过程将在下面讨论。取得<code>IMP</code>后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p>
<p>通过取得<code>IMP</code>，我们可以跳过Runtime的消息传递机制，直接执行<code>IMP</code>指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</p>
<h2 id="method">Method</h2>
<p>介绍完<code>SEL</code>和<code>IMP</code>，我们就可以来讲讲<code>Method</code>了。<code>Method</code>用于表示类定义中的方法，则定义如下：</p>
<pre><code class="language-c">typedef struct objc_method *Method;

struct objc_method {
    SEL method_name                	OBJC2_UNAVAILABLE;	// 方法名
    char *method_types              OBJC2_UNAVAILABLE;
    IMP method_imp             			OBJC2_UNAVAILABLE;	// 方法实现
}
</code></pre>
<p>我们可以看到该结构体中包含一个<code>SEL</code>和<code>IMP</code>，实际上相当于在<code>SEL</code>和<code>IMP</code>之间作了一个映射。有了SEL，我们便可以找到对应的<code>IMP</code>，从而调用方法的实现代码。具体操作流程我们将在下面讨论。</p>
<h3 id="objc_method_description">objc_method_description</h3>
<p><code>objc_method_description</code>定义了一个Objective-C方法，其定义如下：</p>
<pre><code class="language-c">struct objc_method_description { SEL name; char *types; };
</code></pre>
<p>说明：</p>
<ul>
<li>types是方法返回类型，</li>
</ul>
<h1 id="方法相关操作函数">方法相关操作函数</h1>
<p>Runtime提供了一系列的方法来处理与方法相关的操作。包括方法本身及SEL。本节我们介绍一下这些函数。</p>
<h2 id="方法">方法</h2>
<p>方法操作相关函数包括下以：</p>
<pre><code class="language-c">// 调用指定方法的实现
id method_invoke ( id receiver, Method m, ... );
// 调用返回一个数据结构的方法的实现
void method_invoke_stret ( id receiver, Method m, ... );
// 获取方法名
SEL method_getName ( Method m );
// 返回方法的实现
IMP method_getImplementation ( Method m );
// 获取描述方法参数和返回值类型的字符串
const char * method_getTypeEncoding ( Method m );
// 获取方法的返回值类型的字符串
char * method_copyReturnType ( Method m );
// 获取方法的指定位置参数的类型字符串
char * method_copyArgumentType ( Method m, unsigned int index );
// 通过引用返回方法的返回值类型字符串
void method_getReturnType ( Method m, char *dst, size_t dst_len );
// 返回方法的参数的个数
unsigned int method_getNumberOfArguments ( Method m );
// 通过引用返回方法指定位置参数的类型字符串
void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );
// 返回指定方法的方法描述结构体
struct objc_method_description * method_getDescription ( Method m );
// 设置方法的实现
IMP method_setImplementation ( Method m, IMP imp );
// 交换两个方法的实现
void method_exchangeImplementations ( Method m1, Method m2 );
</code></pre>
<p>说明：</p>
<ul>
<li><code>method_invoke</code>函数，返回的是实际实现的返回值。参数<code>receiver</code>不能为空。这个方法的效率会比<code>method_getImplementation</code>和<code>method_getName</code>更快。</li>
<li><code>method_getName</code>函数，返回的是一个<code>SEL</code>。如果想获取方法名的C字符串，可以使用<code>sel_getName(method_getName(method))</code>。</li>
<li><code>method_getReturnType</code>函数，类型字符串会被拷贝到<code>dst</code>中。</li>
<li><code>method_setImplementation</code>函数，注意该函数返回值是方法之前的实现。</li>
</ul>
<h2 id="方法选择器">方法选择器</h2>
<p>选择器相关的操作函数包括：</p>
<pre><code class="language-c">// 返回给定选择器指定的方法的名称
const char * sel_getName ( SEL sel );
// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器
SEL sel_registerName ( const char *str );
// 在Objective-C Runtime系统中注册一个方法
SEL sel_getUid ( const char *str );
// 比较两个选择器
BOOL sel_isEqual ( SEL lhs, SEL rhs );
</code></pre>
<p>说明：</p>
<ul>
<li><code>sel_registerName</code>函数：在我们将一个方法添加到类定义时，我们必须在Objective-C Runtime系统中注册一个方法名以获取方法的选择器。</li>
</ul>
<h1 id="方法调用流程">方法调用流程</h1>
<p>在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式<code>[receiver message]</code>转化为一个消息函数的调用，即<code>objc_msgSend</code>。这个函数将消息接收者和方法名作为其基础参数，如以下所示：</p>
<pre><code class="language-c">objc_msgSend(receiver, selector)
</code></pre>
<p>如果消息中还有其它参数，则该方法的形式如下所示：</p>
<pre><code class="language-c">objc_msgSend(receiver, selector, arg1, arg2, ...)
</code></pre>
<p>这个函数完成了动态绑定的所有事情：</p>
<ol>
<li>首先它找到<code>selector</code>对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现。</li>
<li>它调用方法实现，并将接收者对象及方法的所有参数传给它。</li>
<li>最后，它将实现返回的值作为它自己的返回值。</li>
</ol>
<p>消息的关键在于我们前面章节讨论过的结构体<code>objc_class</code>，这个结构体有两个字段是我们在分发消息的关注的：</p>
<ol>
<li>指向父类的指针</li>
<li>一个类的方法分发表，即<code>methodLists</code>。</li>
</ol>
<p>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系。</p>
<p>下图演示了这样一个消息的基本框架：</p>
<figure data-type="image" tabindex="2"><img src="http://res.niuxuewei.com/2020-03-05-041737.gif" alt="messaging1" loading="lazy"></figure>
<p>当消息发送给一个对象时，<code>objc_msgSend</code>通过对象的<code>isa</code>指针获取到类的结构体，然后在方法分发表里面查找方法的<code>selector</code>。如果没有找到<code>selector</code>，则通过<code>objc_msgSend</code>结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的<code>selector</code>。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到<code>selector</code>，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到<code>selector</code>，则会走消息转发流程，这个我们在后面讨论。</p>
<p>为了加速消息的处理，运行时系统缓存使用过的<code>selector</code>及对应的方法的地址。这点我们在<a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/">前面</a>讨论过，不再重复。</p>
<h2 id="隐藏参数">隐藏参数</h2>
<p><code>objc_msgSend</code>有两个隐藏参数：</p>
<ol>
<li>消息接收对象</li>
<li>方法的selector</li>
</ol>
<p>这两个参数为方法的实现提供了调用者的信息。之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明。它们是在编译期被插入实现代码的。</p>
<p>虽然这些参数没有显示声明，但在代码中仍然可以引用它们。我们可以使用<code>self</code>来引用接收者对象，使用<code>_cmd</code>来引用选择器。如下代码所示：</p>
<pre><code class="language-objc">- strange
{
    id  target = getTheReceiver();
    SEL method = getTheMethod();

    if ( target == self || method == _cmd )
        return nil;

    return [target performSelector:method];
}
</code></pre>
<p>当然，这两个参数我们用得比较多的是<code>self</code>，<code>_cmd</code>在实际中用得比较少。</p>
<h2 id="获取方法地址">获取方法地址</h2>
<p>Runtime中方法的动态绑定让我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来得那么直接。当然，方法的缓存一定程度上解决了这一问题。</p>
<p>我们上面提到过，如果想要避开这种动态绑定方式，我们可以获取方法实现的地址，然后像调用函数一样来直接调用它。特别是当我们需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。</p>
<p>NSObject类提供了<code>methodForSelector:</code>方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将<code>methodForSelector:</code>返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。</p>
<p>我们通过以下代码来看看<code>methodForSelector:</code>的使用：</p>
<pre><code class="language-objc">void (*setter)(id, SEL, BOOL);
int i;

setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];

for (i = 0 ; i &lt; 1000 ; i++)
    setter(targetList[i], @selector(setFilled:), YES);
</code></pre>
<p>这里需要注意的就是函数指针的前两个参数必须是<code>id</code>和<code>SEL</code>。</p>
<p>当然这种方式只适合于在类似于<code>for</code>循环这种情况下频繁调用同一方法，以提高性能的情况。另外，<code>methodForSelector:</code>是由Cocoa运行时提供的；它不是Objective-C语言的特性。</p>
<h1 id="消息转发">消息转发</h1>
<p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以<code>[object message]</code>的方式调用方法，如果<code>object</code>无法响应<code>message</code>消息时，编译器会报错。但如果是以<code>perform...</code>的形式来调用，则需要等到运行时才能确定object是否能接收<code>message</code>消息。如果不能，则程序崩溃。</p>
<p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用<code>respondsToSelector:</code>来判断一下。如下代码所示：</p>
<pre><code class="language-objc">if ([self respondsToSelector:@selector(method)]) {
    [self performSelector:@selector(method)];
}
</code></pre>
<p>不过，我们这边想讨论下不使用<code>respondsToSelector:</code>判断的情况。这才是我们这一节的重点。</p>
<p>当一个对象无法接收某一消息时，就会启动所谓**消息转发(message forwarding)**机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：</p>
<pre><code>-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940

*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940'
</code></pre>
<p>这段异常信息实际上是由NSObject的<code>doesNotRecognizeSelector</code>方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p>
<p>消息转发机制基本上分为三个步骤：</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ol>
<p>下面我们详细讨论一下这三个步骤。</p>
<h2 id="动态方法解析">动态方法解析</h2>
<p>对象在接收到未知的消息时，首先会调用所属类的类方法<code>+resolveInstanceMethod:</code>(实例方法)或者<code>+resolveClassMethod:</code>(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过<code>class_addMethod</code>函数动态添加到类里面就可以了。如下代码所示：</p>
<pre><code class="language-objc">void functionForMethod1(id self, SEL _cmd) {
   NSLog(@&quot;%@, %p&quot;, self, _cmd);
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {

    NSString *selectorString = NSStringFromSelector(sel);
    if ([selectorString isEqualToString:@&quot;method1&quot;]) {
        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);
    }

    return [super resolveInstanceMethod:sel];
}

// call method1 by performSelector
[self performSelector:@selector(method1)]
</code></pre>
<p>不过这种方案更多的是为了实现<code>@dynamic</code>属性。</p>
<h2 id="备用接收者">备用接收者</h2>
<p>如果在上一步无法处理消息，则Runtime会继续调以下方法：</p>
<pre><code class="language-objc">- (id)forwardingTargetForSelector:(SEL)aSelector
</code></pre>
<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是<code>self</code>自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理<code>aSelector</code>，则应该调用父类的实现来返回结果。</p>
<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示：</p>
<pre><code class="language-objc">// SUTRuntimeMethod.h
#import &lt;Foundation/Foundation.h&gt;

@interface SUTRuntimeMethod : NSObject

+ (instancetype)object;
- (void)test;

@end
</code></pre>
<pre><code class="language-objc">// SUTRuntimeMethod.m
#import &quot;SUTRuntimeMethod.h&quot;


@interface SUTRuntimeMethodHelper: NSObject

- (void)method2;

@end

@implementation SUTRuntimeMethodHelper

- (void)method2 {
    NSLog(@&quot;self: %@, sel: %p&quot;, self, _cmd);
}

@end

#pragma mark - SUTRuntimeMethod

@interface SUTRuntimeMethod () {
    SUTRuntimeMethodHelper *_helper;
}
@end

@implementation SUTRuntimeMethod

+ (instancetype)object {
    return [[self alloc] init];
}

- (instancetype)init {
    self = [super init];
    if (self != nil) {
        _helper = [[SUTRuntimeMethodHelper alloc] init];
    }
    return self;
}

- (void)test {
    [self performSelector:@selector(method2)];
}

- (id)forwardingTargetForSelector:(SEL)aSelector {
    NSLog(@&quot;forwardingTargetForSelector&quot;);

    NSString *selectorString = NSStringFromSelector(aSelector);
    if ([selectorString isEqualToString:@&quot;method2&quot;]) {
        return _helper;
    }

    return [super forwardingTargetForSelector:aSelector];
}

@end
</code></pre>
<pre><code class="language-objc">// main.m
#import &lt;Foundation/Foundation.h&gt;
#import &quot;SUTRuntimeMethod.h&quot;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        SUTRuntimeMethod *method = [SUTRuntimeMethod object];
        [method test];
    }
    return 0;
}
</code></pre>
<p>输出结果</p>
<pre><code>2020-03-05 19:20:58.197 ObjectiveCRuntime[74801:331213] forwardingTargetForSelector
2020-03-05 19:20:58.198 ObjectiveCRuntime[74801:331213] self: &lt;SUTRuntimeMethodHelper: 0x7fa04bd04ed0&gt;, sel: 0x100d3eeba
</code></pre>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h2 id="完整消息转发">完整消息转发</h2>
<p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：</p>
<pre><code class="language-objc">- (void)forwardInvocation:(NSInvocation *)anInvocation
</code></pre>
<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。==对象会创建一个表示消息的<code>NSInvocation</code>对象，把与尚未处理的消息有关的全部细节都封装在<code>anInvocation</code>中，包括<code>selector</code>，目标(<code>target</code>)和参数。==我们可以在<code>forwardInvocation</code>方法中选择将消息转发给其它对象。</p>
<p><code>forwardInvocation:</code>方法的实现有两个任务：</p>
<ol>
<li>定位可以响应封装在<code>anInvocation</code>中的消息的对象。这个对象不需要能处理所有未知消息。</li>
<li>使用<code>anInvocation</code>作为参数，将消息发送到选中的对象。<code>anInvocation</code>将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ol>
<p>不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p>
<p>还有一个很重要的问题，我们必须重写以下方法：</p>
<pre><code class="language-objc">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
</code></pre>
<p>消息转发机制使用从这个方法中获取的信息来创建<code>NSInvocation</code>对象。因此我们必须重写这个方法，为给定的<code>selector</code>提供一个合适的方法签名。</p>
<p>完整的示例如下所示：</p>
<pre><code class="language-objc">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {

    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];
    if (!signature) {
        if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) {
            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];
        }
    }

    return signature;
}

- (void)forwardInvocation:(NSInvocation *)anInvocation {
    if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) {
        [anInvocation invokeWithTarget:_helper];
    }
}
</code></pre>
<p>NSObject的<code>forwardInvocation:</code>方法实现只是简单调用了<code>doesNotRecognizeSelector:</code>方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>
<p>从某种意义上来讲，<code>forwardInvocation:</code>就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。</p>
<h2 id="消息转发与多重继承">消息转发与多重继承</h2>
<p>回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。</p>
<p>不过消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者。如<code>respondsToSelector:</code>和<code>isKindOfClass:</code>只能用于继承体系，而不能用于转发链。便如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：</p>
<pre><code class="language-objc">- (BOOL)respondsToSelector:(SEL)aSelector
{
	if ( [super respondsToSelector:aSelector])
		return YES;
	else {
		/* Here, test whether the aSelector message can     *
		 * be forwarded to another object and whether that  *
		 * object can respond to it. Return YES if it can.  */
	}

	return NO; 	
}
</code></pre>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://www.nxw.name/tag/fFflLhA-K/">
            <span class="flex-auto">objective-c</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://www.nxw.name/tag/4eHHXxUU0/">
            <span class="flex-auto">swift</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://www.nxw.name/tag/D5fQkPvhp8/">
            <span class="flex-auto">ios</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://www.nxw.name/tag/C2Fgvc8o4_/">
            <span class="flex-auto">macOS</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://www.nxw.name/tag/aAKuw7hWJZ/">
            <span class="flex-auto">dev</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://www.nxw.name/post/how-delegateproxy-works-in-rxswift/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  How DelegateProxy works in RxSwift?
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://www.nxw.name/post/shu-liang-tong-ji-zhong-xiang-guan-gai-nian-yi-ji-fen-bu-han-shu-tui-dao-de-xiang-guan-guo-cheng/">
                <h3 class="post-title">
                  数量统计中相关概念以及分布函数推导的相关过程
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://geektutu.github.io/hexo-theme-geektutu/js/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '95da5e6dfbe94e9621c5',
    clientSecret: '6b6510006d4bd9b042323bc2c5b1374561942033',
    repo: 'xav1er.github.io',
    owner: 'xavier-niu',
    admin: ['xavier-niu'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false,  // Facebook-like distraction free mode
    language: 'en'
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://www.nxw.name/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
